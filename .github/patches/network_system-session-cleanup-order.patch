From c37da3f618cdd72959faacdf76971be1ec0d09a5 Mon Sep 17 00:00:00 2001
From: kcenon <kcenon@naver.com>
Date: Mon, 22 Dec 2025 13:37:59 +0900
Subject: [PATCH] fix(server): fix session cleanup order to prevent heap
 corruption

Move sessions_.clear() after io_context has fully stopped to ensure
all pending async callbacks have finished executing before session
objects are destroyed.

This fixes "corrupted size vs. prev_size" heap corruption errors
that occurred when async callbacks tried to access destroyed session
memory during server shutdown with active connections.
---
 src/core/messaging_server.cpp        | 16 ++++++++++++----
 src/core/secure_messaging_server.cpp | 18 +++++++++++++-----
 2 files changed, 25 insertions(+), 9 deletions(-)

diff --git a/src/core/messaging_server.cpp b/src/core/messaging_server.cpp
index a8b4ff9..8f5aaa4 100644
--- a/src/core/messaging_server.cpp
+++ b/src/core/messaging_server.cpp
@@ -184,7 +184,9 @@ namespace kcenon::network::core
 				cleanup_timer_->cancel();
 			}
 
-			// Step 2: Stop all active sessions
+			// Step 2: Stop all active sessions (close sockets, stop reading)
+			// NOTE: Do NOT clear sessions here - they may still be referenced by
+			// pending async callbacks. We must wait for io_context to finish first.
 			{
 				std::lock_guard<std::mutex> lock(sessions_mutex_);
 				for (auto& sess : sessions_)
@@ -194,7 +196,6 @@ namespace kcenon::network::core
 						sess->stop_session();
 					}
 				}
-				sessions_.clear();
 			}
 
 			// Step 3: Release work guard to allow io_context to finish
@@ -210,17 +211,24 @@ namespace kcenon::network::core
 			}
 
 			// Step 5: Wait for io_context task to complete
+			// This ensures all pending async callbacks have finished executing
 			if (io_context_future_.valid())
 			{
 				io_context_future_.wait();
 			}
 
-			// Step 6: Release resources explicitly to ensure cleanup
+			// Step 6: NOW it's safe to clear sessions - all async operations are done
+			{
+				std::lock_guard<std::mutex> lock(sessions_mutex_);
+				sessions_.clear();
+			}
+
+			// Step 7: Release resources explicitly to ensure cleanup
 			acceptor_.reset();
 			cleanup_timer_.reset();
 			io_context_.reset();
 
-			// Step 7: Signal the promise for wait_for_stop()
+			// Step 8: Signal the promise for wait_for_stop()
 			if (stop_promise_.has_value())
 			{
 				try
diff --git a/src/core/secure_messaging_server.cpp b/src/core/secure_messaging_server.cpp
index 7bed474..fd15f05 100644
--- a/src/core/secure_messaging_server.cpp
+++ b/src/core/secure_messaging_server.cpp
@@ -252,7 +252,9 @@ namespace kcenon::network::core
 				cleanup_timer_->cancel();
 			}
 
-			// Step 2: Stop all active sessions
+			// Step 2: Stop all active sessions (close sockets, stop reading)
+			// NOTE: Do NOT clear sessions here - they may still be referenced by
+			// pending async callbacks. We must wait for io_context to finish first.
 			{
 				std::lock_guard<std::mutex> lock(sessions_mutex_);
 				for (auto& sess : sessions_)
@@ -262,7 +264,6 @@ namespace kcenon::network::core
 						sess->stop_session();
 					}
 				}
-				sessions_.clear();
 			}
 
 			// Step 3: Release work guard to allow io_context to finish
@@ -277,7 +278,8 @@ namespace kcenon::network::core
 				io_context_->stop();
 			}
 
-			// Step 4: Wait for io_context task to complete
+			// Step 5: Wait for io_context task to complete
+			// This ensures all pending async callbacks have finished executing
 			if (io_context_future_.valid())
 			{
 				try {
@@ -288,13 +290,19 @@ namespace kcenon::network::core
 				}
 			}
 
-			// Step 5: Release resources explicitly to ensure cleanup
+			// Step 6: NOW it's safe to clear sessions - all async operations are done
+			{
+				std::lock_guard<std::mutex> lock(sessions_mutex_);
+				sessions_.clear();
+			}
+
+			// Step 7: Release resources explicitly to ensure cleanup
 			acceptor_.reset();
 			cleanup_timer_.reset();
 			thread_pool_.reset();
 			io_context_.reset();
 
-			// Step 6: Signal the promise for wait_for_stop()
+			// Step 8: Signal the promise for wait_for_stop()
 			if (stop_promise_.has_value())
 			{
 				try
-- 
2.50.1 (Apple Git-155)

