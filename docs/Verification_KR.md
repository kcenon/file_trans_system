# 파일 전송 시스템 - 소프트웨어 검증 명세서

## 문서 정보

| 항목 | 내용 |
|------|------|
| **프로젝트명** | file_trans_system |
| **문서 유형** | 소프트웨어 검증 명세서 (SVS) |
| **버전** | 1.0.0 |
| **상태** | 초안 |
| **작성일** | 2025-12-11 |
| **작성자** | kcenon@naver.com |
| **관련 문서** | SRS_KR.md v1.1.0, SDS_KR.md v1.0.0 |

---

## 1. 소개

### 1.1 목적

본 소프트웨어 검증 명세서(SVS)는 **file_trans_system** 구현이 소프트웨어 요구사항 명세서(SRS)에 명시된 모든 요구사항을 충족하는지 검증하기 위한 접근 방식, 방법 및 테스트 케이스를 정의합니다.

### 1.2 범위

본 문서는 다음을 다룹니다:
- 검증 방법론 및 접근 방식
- SRS 추적성이 있는 테스트 케이스 명세
- 각 요구사항에 대한 인수 조건
- 품질 게이트 및 마일스톤
- 검증 도구 및 환경

### 1.3 검증 방법

| 방법 | 코드 | 설명 |
|------|------|------|
| **검사(Inspection)** | I | 코드 리뷰, 문서 리뷰, 정적 분석 |
| **분석(Analysis)** | A | 수학적 분석, 시뮬레이션, 알고리즘 검증 |
| **시연(Demonstration)** | D | 기능 시연, 워크플로우 검증 |
| **테스트(Test)** | T | 단위 테스트, 통합 테스트, 시스템 테스트, 벤치마크 |

### 1.4 참조 문서

| 문서 | 설명 |
|------|------|
| SRS_KR.md v1.1.0 | 소프트웨어 요구사항 명세서 |
| SDS_KR.md v1.0.0 | 소프트웨어 설계 명세서 |
| IEEE 1012-2016 | 시스템, 소프트웨어 및 하드웨어 V&V 표준 |
| ISO/IEC 29119 | 소프트웨어 테스팅 표준 |

---

## 2. 검증 접근 방식

### 2.1 검증 전략

```
┌─────────────────────────────────────────────────────────────────────┐
│                       검증 계층 구조                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  레벨 4: 시스템 검증                                                 │
│  ├── 종단간 전송 시나리오                                            │
│  ├── 성능 벤치마크                                                   │
│  └── 보안 검증                                                       │
│                                                                      │
│  레벨 3: 통합 검증                                                   │
│  ├── 파이프라인 통합 테스트                                          │
│  ├── 컴포넌트 상호작용 테스트                                        │
│  └── 프로토콜 검증                                                   │
│                                                                      │
│  레벨 2: 컴포넌트 검증                                               │
│  ├── 모듈 단위 테스트                                                │
│  ├── 인터페이스 검증                                                 │
│  └── 오류 처리 테스트                                                │
│                                                                      │
│  레벨 1: 코드 검증                                                   │
│  ├── 정적 분석                                                       │
│  ├── 코드 리뷰                                                       │
│  └── 코딩 표준 준수                                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 테스트 환경

| 구성요소 | 사양 |
|----------|------|
| **OS** | Linux (Ubuntu 22.04+), macOS 11+, Windows 10+ |
| **컴파일러** | GCC 11+, Clang 14+, MSVC 19.29+ |
| **테스트 프레임워크** | Google Test 1.12+, Catch2 3.x |
| **벤치마크** | Google Benchmark 1.7+ |
| **새니타이저** | AddressSanitizer, ThreadSanitizer, UBSan |
| **커버리지** | gcov/llvm-cov 80% 목표 |

### 2.3 품질 게이트

| 게이트 | 조건 | 차단 여부 |
|--------|------|-----------|
| **QG-01** | 모든 단위 테스트 통과 | 예 |
| **QG-02** | 코드 커버리지 ≥ 80% | 예 |
| **QG-03** | AddressSanitizer 오류 0건 | 예 |
| **QG-04** | ThreadSanitizer 경고 0건 | 예 |
| **QG-05** | 모든 통합 테스트 통과 | 예 |
| **QG-06** | 성능 목표 달성 | 예 |
| **QG-07** | API 문서 완료 | 예 |
| **QG-08** | 코드 리뷰 승인 | 예 |

---

## 3. 요구사항 검증 매트릭스

### 3.1 핵심 전송 요구사항 (SRS-CORE)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-CORE-001 | 단일 파일 송신 | T, D | TC-CORE-001, TC-CORE-002 | P0 |
| SRS-CORE-002 | 단일 파일 수신 | T, D | TC-CORE-003, TC-CORE-004 | P0 |
| SRS-CORE-003 | 다중 파일 배치 전송 | T, D | TC-CORE-005, TC-CORE-006 | P0 |

#### TC-CORE-001: 단일 파일 전송 - 소형 파일

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CORE-001 |
| **SRS 추적** | SRS-CORE-001, SRS-CORE-002 |
| **목적** | 소형 파일에 대한 단일 파일 전송 검증 |
| **전제조건** | 송신자와 수신자가 실행 중, 네트워크 연결됨 |
| **테스트 데이터** | 알려진 SHA-256을 가진 1KB, 64KB, 256KB 파일 |

**테스트 단계:**
1. 알려진 내용으로 테스트 파일 생성
2. 소스 파일의 SHA-256 해시 계산
3. `file_sender::send_file()`을 통해 파일 전송 시작
4. 전송 완료 대기
5. 수신된 파일의 SHA-256이 소스와 일치하는지 확인
6. 진행 콜백이 호출되었는지 확인

**예상 결과:**
- 5초 이내에 전송 완료
- SHA-256 해시 일치 (AC-001-1)
- 진행 콜백 최소 1회 호출 (AC-001-3)
- `transfer_result.verified`가 true

---

#### TC-CORE-002: 단일 파일 전송 - 대형 파일

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CORE-002 |
| **SRS 추적** | SRS-CORE-001, SRS-CORE-002 |
| **목적** | 대형 파일(1GB+)에 대한 단일 파일 전송 검증 |
| **전제조건** | 충분한 디스크 공간, 네트워크 대역폭 사용 가능 |
| **테스트 데이터** | 랜덤 내용의 1GB, 10GB 파일 |

**테스트 단계:**
1. 대형 테스트 파일(1GB) 생성
2. 시작 시간 기록
3. 파일 전송 시작
4. 진행 콜백 모니터링
5. 완료 후 파일 무결성 확인
6. 실제 처리량 계산

**예상 결과:**
- 전송이 성공적으로 완료됨
- LAN에서 처리량 ≥ 500 MB/s (PERF-001)
- 전송 중 메모리 사용량 < 100MB (PERF-021)
- SHA-256 검증 통과

---

#### TC-CORE-003: 수락 콜백을 통한 파일 수신

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CORE-003 |
| **SRS 추적** | SRS-CORE-002 |
| **목적** | 수신자 수락/거부 콜백 메커니즘 검증 |
| **전제조건** | 수락 콜백이 등록된 수신자 실행 중 |

**테스트 단계:**
1. 100MB 미만 파일에 대해 `true`를 반환하는 수락 콜백 등록
2. 50MB 파일 전송 → 수락되어야 함
3. 200MB 파일 전송 → 거부되어야 함
4. 거부 오류 코드(-703) 확인

**예상 결과:**
- 50MB 파일 전송 성공
- 200MB 파일이 오류 코드 -703으로 거부됨 (AC-002-2)
- 거부가 적절히 로깅됨

---

#### TC-CORE-004: 파일 수신 - 손상된 청크 감지

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CORE-004 |
| **SRS 추적** | SRS-CORE-002, SRS-CHUNK-003 |
| **목적** | 수신 시 손상된 청크 감지 검증 |
| **전제조건** | 네트워크 오류 주입 기능 |

**테스트 단계:**
1. 파일 전송 시작
2. 전송 중 청크에 비트 플립 오류 주입 (테스트 후크 통해)
3. CRC32 불일치 감지 확인
4. 청크 재전송 요청 확인
5. 전송 성공적으로 완료

**예상 결과:**
- CRC32를 통해 손상 감지 (AC-CHUNK-003-2)
- 손상된 청크에 대해 오류 코드 -721 보고
- 재시도 후 전송 완료
- 최종 SHA-256 검증 통과

---

#### TC-CORE-005: 배치 전송 - 다중 파일

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CORE-005 |
| **SRS 추적** | SRS-CORE-003 |
| **목적** | 다중 파일 배치 전송 검증 |
| **테스트 데이터** | 다양한 크기(1KB ~ 10MB)의 100개 파일 |

**테스트 단계:**
1. 100개 테스트 파일 생성
2. 각 파일의 SHA-256 계산
3. 모든 100개 파일로 `file_sender::send_files()` 호출
4. 개별 파일 진행 상황 추적
5. 모든 파일이 올바르게 수신되었는지 확인

**예상 결과:**
- 100개 파일 모두 전송됨 (AC-003-1)
- 개별 상태 추적 사용 가능 (AC-003-2)
- 배치 진행 상황에 파일별 분석 표시
- 총 시간 < 개별 전송 합계 (병렬성)

---

#### TC-CORE-006: 배치 전송 - 부분 실패 복구

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CORE-006 |
| **SRS 추적** | SRS-CORE-003 |
| **목적** | 단일 파일 실패 후 배치 전송 계속 검증 |

**테스트 단계:**
1. 10개 파일 배치 생성
2. 전송 시작 후 파일 #5 삭제 (실패 시뮬레이션)
3. 나머지 파일이 계속 전송되는지 확인
4. 최종 상태에서 파일 #5가 실패로 보고되는지 확인

**예상 결과:**
- 파일 1-4 및 6-10 전송 성공
- 파일 #5가 오류 코드 -743 (file_not_found) 보고
- 부분 실패가 배치를 중단하지 않음 (AC-003-3)

---

### 3.2 청크 관리 요구사항 (SRS-CHUNK)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-CHUNK-001 | 파일 분할 | T, A | TC-CHUNK-001, TC-CHUNK-002 | P0 |
| SRS-CHUNK-002 | 파일 조립 | T | TC-CHUNK-003, TC-CHUNK-004 | P0 |
| SRS-CHUNK-003 | 청크 체크섬 | T | TC-CHUNK-005, TC-CHUNK-006 | P0 |
| SRS-CHUNK-004 | 파일 해시 검증 | T | TC-CHUNK-007, TC-CHUNK-008 | P0 |

#### TC-CHUNK-001: 청크 크기 설정

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-001 |
| **SRS 추적** | SRS-CHUNK-001 |
| **목적** | 설정 가능한 청크 크기 검증 |

**테스트 단계:**
1. chunk_size = 64KB (최소값) 설정
2. 1MB 파일 전송 → 16개 청크 생성 확인
3. chunk_size = 1MB (최대값) 설정
4. 1MB 파일 전송 → 1개 청크 생성 확인
5. chunk_size = 32KB (최소값 미만) 설정 → 오류 확인

**예상 결과:**
- 64KB 청크: 정확히 16개 청크 (AC-CHUNK-001-2)
- 1MB 청크: 정확히 1개 청크
- 유효하지 않은 크기는 오류 코드 -790 (config_invalid) 반환

---

#### TC-CHUNK-002: 마지막 청크 처리

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-002 |
| **SRS 추적** | SRS-CHUNK-001 |
| **목적** | 마지막 청크 크기 처리 검증 |

**테스트 단계:**
1. chunk_size = 256KB 설정
2. 600KB (2.34 청크) 크기 파일 전송
3. 처음 2개 청크가 각각 256KB인지 확인
4. 마지막 청크가 88KB인지 확인
5. 청크 #3에 last_chunk 플래그 설정 확인

**예상 결과:**
- 마지막 청크 크기 = 88KB (< chunk_size) (AC-CHUNK-001-3)
- 마지막 청크에 `chunk_flags::last_chunk` 설정
- 파일이 올바르게 재구성됨

---

#### TC-CHUNK-003: 순서가 뒤바뀐 청크 조립

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-003 |
| **SRS 추적** | SRS-CHUNK-002 |
| **목적** | 순서가 뒤바뀐 청크 재조립 검증 |

**테스트 단계:**
1. 10개 청크로 파일 전송
2. 인위적 지연을 주입하여 청크 순서 변경 (3,1,5,2,4,7,6,8,10,9)
3. 순차적 쓰기가 가능할 때까지 청크 버퍼링 확인
4. 최종 파일 무결성 확인

**예상 결과:**
- 청크가 올바르게 재조립됨 (AC-CHUNK-002-1)
- 데이터 손상 없음
- SHA-256 검증 통과

---

#### TC-CHUNK-004: 중복 청크 처리

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-004 |
| **SRS 추적** | SRS-CHUNK-002 |
| **목적** | 중복 청크가 멱등성 있게 처리되는지 검증 |

**테스트 단계:**
1. 5개 청크로 파일 전송
2. 청크 #3을 두 번 전송 (테스트 후크 통해)
3. 중복이 무시되는지 확인
4. 파일이 올바르게 조립되는지 확인

**예상 결과:**
- 중복 청크가 오류 없이 무시됨 (AC-CHUNK-002-3)
- 파일 무결성 유지
- 출력 파일에 중복 데이터 없음

---

#### TC-CHUNK-005: CRC32 계산 성능

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-005 |
| **SRS 추적** | SRS-CHUNK-003 |
| **목적** | CRC32 오버헤드가 최소인지 검증 |

**테스트 단계:**
1. 256KB 청크에 대한 CRC32 계산 벤치마크
2. CRC32 유무에 따른 시간 측정
3. 오버헤드 비율 계산

**예상 결과:**
- CRC32 오버헤드 < 전송 시간의 1% (AC-CHUNK-003-3)
- CRC32 처리량 > 5 GB/s

---

#### TC-CHUNK-006: CRC32 손상 감지

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-006 |
| **SRS 추적** | SRS-CHUNK-003 |
| **목적** | CRC32가 단일 비트 오류를 감지하는지 검증 |

**테스트 단계:**
1. 알려진 CRC32를 가진 청크 생성
2. 청크 데이터에서 단일 비트 반전
3. CRC32 불일치 감지 확인
4. 오류 코드 -721 반환 확인

**예상 결과:**
- 단일 비트 오류 감지 (AC-CHUNK-003-1)
- 오류 코드 -721 (chunk_checksum_error) 반환
- 손상된 청크 거부됨

---

#### TC-CHUNK-007: SHA-256 파일 검증

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-007 |
| **SRS 추적** | SRS-CHUNK-004 |
| **목적** | SHA-256이 올바르게 계산되고 검증되는지 검증 |

**테스트 단계:**
1. 소스 파일의 SHA-256 계산
2. 파일 전송
3. SHA-256이 transfer_result에 포함되는지 확인
4. 소스 파일 해시와 비교

**예상 결과:**
- 송신 전 SHA-256 계산 (AC-CHUNK-004-1)
- 수신 후 SHA-256 검증
- transfer_result에 해시 포함 (AC-CHUNK-004-3)
- 해시 일치

---

#### TC-CHUNK-008: SHA-256 불일치 감지

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-008 |
| **SRS 추적** | SRS-CHUNK-004 |
| **목적** | SHA-256 불일치가 감지되는지 검증 |

**테스트 단계:**
1. 파일 전송 시작
2. 검증 전 수신된 파일 수정 (테스트 후크 통해)
3. SHA-256 불일치 감지 확인
4. 오류 코드 -723 반환 확인

**예상 결과:**
- 해시 불일치 감지
- 오류 코드 -723 (file_hash_mismatch) 반환 (AC-CHUNK-004-2)
- 전송이 실패로 표시됨

---

### 3.3 압축 요구사항 (SRS-COMP)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-COMP-001 | LZ4 압축 | T, A | TC-COMP-001, TC-COMP-002 | P0 |
| SRS-COMP-002 | LZ4 해제 | T | TC-COMP-003, TC-COMP-004 | P0 |
| SRS-COMP-003 | 적응형 감지 | T | TC-COMP-005, TC-COMP-006 | P1 |
| SRS-COMP-004 | 압축 모드 설정 | T | TC-COMP-007, TC-COMP-008 | P0 |
| SRS-COMP-005 | 압축 통계 | T | TC-COMP-009 | P2 |

#### TC-COMP-001: LZ4 압축 속도 벤치마크

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-001 |
| **SRS 추적** | SRS-COMP-001, PERF-003 |
| **목적** | LZ4 압축 속도가 목표를 충족하는지 검증 |

**테스트 단계:**
1. 100MB 압축 가능한 테스트 데이터 생성 (텍스트)
2. LZ4 압축 10회 반복 실행
3. 평균 처리량 계산
4. 압축률 기록

**예상 결과:**
- 압축 속도 ≥ 400 MB/s (AC-COMP-001-1)
- 텍스트 데이터에 대해 압축률 ≥ 2.0:1

---

#### TC-COMP-002: LZ4-HC 고압축 모드

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-002 |
| **SRS 추적** | SRS-COMP-001 |
| **목적** | LZ4-HC 압축 특성 검증 |

**테스트 단계:**
1. LZ4 표준으로 100MB 파일 압축
2. LZ4-HC (레벨 9)로 동일 파일 압축
3. 압축률 비교
4. 해제가 동일한 출력을 생성하는지 확인

**예상 결과:**
- LZ4-HC 비율 > LZ4 표준 비율
- LZ4-HC 압축 속도 ≥ 50 MB/s
- 둘 다 동일한 원본 데이터로 해제됨 (AC-COMP-001-3)

---

#### TC-COMP-003: LZ4 해제 속도 벤치마크

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-003 |
| **SRS 추적** | SRS-COMP-002, PERF-004 |
| **목적** | LZ4 해제 속도가 목표를 충족하는지 검증 |

**테스트 단계:**
1. 100MB 테스트 데이터 압축
2. 해제 10회 반복 실행
3. 평균 처리량 계산
4. 해제된 데이터 무결성 확인

**예상 결과:**
- 해제 속도 ≥ 1.5 GB/s (AC-COMP-002-1)
- 해제된 데이터가 원본과 정확히 일치

---

#### TC-COMP-004: 해제 오류 처리

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-004 |
| **SRS 추적** | SRS-COMP-002 |
| **목적** | 해제 오류 처리 검증 |

**테스트 단계:**
1. 손상된 압축 데이터 생성
2. 해제 시도
3. 적절한 오류 반환 확인

**예상 결과:**
- 유효하지 않은 데이터는 오류 코드 -781 반환 (AC-COMP-002-2)
- 버퍼 너무 작음은 오류 코드 -782 반환
- 크래시나 정의되지 않은 동작 없음

---

#### TC-COMP-005: 적응형 압축 - 압축 가능한 데이터

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-005 |
| **SRS 추적** | SRS-COMP-003 |
| **목적** | 압축 가능한 데이터에 대한 적응형 감지 검증 |

**테스트 단계:**
1. 텍스트 파일 생성 (높은 압축률)
2. 적응형 압축 모드 활성화
3. 파일 전송
4. 압축이 적용되었는지 확인

**예상 결과:**
- 텍스트 파일이 압축 가능으로 감지됨 (AC-COMP-003-3)
- 압축 적용됨
- 감지 시간 < 100μs (AC-COMP-003-1)

---

#### TC-COMP-006: 적응형 압축 - 압축 불가능한 데이터

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-006 |
| **SRS 추적** | SRS-COMP-003 |
| **목적** | 압축 불가능한 데이터에 대한 적응형 감지 검증 |

**테스트 단계:**
1. 이미 압축된 파일 생성 또는 사용 (ZIP, JPEG)
2. 적응형 압축 모드 활성화
3. 파일 전송
4. 압축이 건너뛰어졌는지 확인

**예상 결과:**
- 압축된 파일이 압축 불가능으로 감지됨 (AC-COMP-003-2)
- 압축 건너뛰어짐 (chunks_skipped 증가)
- 이중 압축 오버헤드 없음

---

#### TC-COMP-007: 압축 모드 - 비활성화

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-007 |
| **SRS 추적** | SRS-COMP-004 |
| **목적** | 비활성화된 압축 모드 검증 |

**테스트 단계:**
1. compression_mode = disabled 설정
2. 압축 가능한 파일 전송
3. 원시 데이터가 전송되었는지 확인 (압축 플래그 없음)

**예상 결과:**
- 압축 적용 안 됨 (AC-COMP-004-1)
- `chunk_flags::compressed` 설정 안 됨
- bytes_transferred == bytes_on_wire

---

#### TC-COMP-008: 압축 모드 - 활성화

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-008 |
| **SRS 추적** | SRS-COMP-004 |
| **목적** | 활성화된 압축 모드 검증 |

**테스트 단계:**
1. compression_mode = enabled 설정
2. 이미 압축된 파일 전송 (ZIP)
3. 비효율적이더라도 압축이 적용되었는지 확인

**예상 결과:**
- 압축 항상 적용 (AC-COMP-004-2)
- 모든 청크에 `chunk_flags::compressed` 설정
- bytes_on_wire > bytes_transferred일 수 있음

---

#### TC-COMP-009: 압축 통계 정확성

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-009 |
| **SRS 추적** | SRS-COMP-005 |
| **목적** | 압축 통계 정확성 검증 |

**테스트 단계:**
1. 혼합 배치 전송 (텍스트 파일 5개, 바이너리 파일 5개)
2. compression_statistics 조회
3. 통계가 실제 동작과 일치하는지 확인

**예상 결과:**
- `total_raw_bytes`가 파일 크기 합계와 일치
- `compression_ratio`가 정확함 (AC-COMP-005-1)
- `chunks_compressed` + `chunks_skipped` = 총 청크
- 통계가 실시간으로 사용 가능 (AC-COMP-005-3)

---

### 3.4 파이프라인 요구사항 (SRS-PIPE)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-PIPE-001 | 송신자 파이프라인 | T, D | TC-PIPE-001, TC-PIPE-002 | P0 |
| SRS-PIPE-002 | 수신자 파이프라인 | T, D | TC-PIPE-003, TC-PIPE-004 | P0 |
| SRS-PIPE-003 | 파이프라인 백프레셔 | T | TC-PIPE-005, TC-PIPE-006 | P1 |
| SRS-PIPE-004 | 파이프라인 통계 | T, D | TC-PIPE-007 | P1 |

#### TC-PIPE-001: 송신자 파이프라인 동시성

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-001 |
| **SRS 추적** | SRS-PIPE-001 |
| **목적** | 송신자 파이프라인 단계가 동시에 실행되는지 검증 |

**테스트 단계:**
1. 파이프라인 단계에 타이밍 마커 계측
2. 대형 파일(1GB) 전송
3. 단계 간 타이밍 중첩 분석
4. 4개 단계 모두 병렬로 실행되는지 확인

**예상 결과:**
- 모든 단계 (read, chunk, compress, send)가 중첩됨 (AC-PIPE-001-1)
- 파이프라인 처리량 > 단일 스레드 처리량
- 단계 기아 없음

---

#### TC-PIPE-002: 송신자 파이프라인 워커 설정

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-002 |
| **SRS 추적** | SRS-PIPE-001 |
| **목적** | 파이프라인 워커 설정 검증 |

**테스트 단계:**
1. io_read workers = 4 (기본값 아님) 설정
2. compression workers = 8 설정
3. 파일 전송 및 통계에서 워커 수 확인
4. 설정이 적용되었는지 확인

**예상 결과:**
- 사용자 정의 워커 수 적용됨 (AC-PIPE-001-3)
- 통계에 올바른 워커 사용률 표시
- 리소스 경합 문제 없음

---

#### TC-PIPE-003: 수신자 파이프라인 동시성

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-003 |
| **SRS 추적** | SRS-PIPE-002 |
| **목적** | 수신자 파이프라인 단계가 동시에 실행되는지 검증 |

**테스트 단계:**
1. 수신자 파이프라인 단계 계측
2. 대형 파일(1GB) 수신
3. 4개 단계 모두 병렬로 실행되는지 확인

**예상 결과:**
- 모든 단계 (recv, decompress, assemble, write)가 중첩됨 (AC-PIPE-002-1)
- 순서가 뒤바뀐 청크가 올바르게 처리됨 (AC-PIPE-002-2)

---

#### TC-PIPE-004: 수신자 파이프라인 설정

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-004 |
| **SRS 추적** | SRS-PIPE-002 |
| **목적** | 수신자 파이프라인 워커 설정 검증 |

**테스트 단계:**
1. 사용자 정의 워커 수 설정
2. 파일 수신
3. 설정이 적용되었는지 확인

**예상 결과:**
- 워커 수 설정 가능 (AC-PIPE-002-3)
- 워커 수에 따라 성능 확장 (한계까지)

---

#### TC-PIPE-005: 백프레셔 - 느린 소비자

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-005 |
| **SRS 추적** | SRS-PIPE-003 |
| **목적** | 소비자가 느릴 때 백프레셔 검증 |

**테스트 단계:**
1. write_queue_size = 4 (작게) 설정
2. 파일 쓰기 단계를 인위적으로 느리게 함
3. 대형 파일 전송
4. 메모리 사용량 및 큐 깊이 모니터링

**예상 결과:**
- 업스트림 단계가 느려짐 (AC-PIPE-003-2)
- 메모리 사용량이 제한됨 (AC-PIPE-003-1)
- 파일 크기와 관계없이 OOM 상황 없음

---

#### TC-PIPE-006: 백프레셔 - 메모리 제한

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-006 |
| **SRS 추적** | SRS-PIPE-003 |
| **목적** | 전송 중 메모리가 제한되는지 검증 |

**테스트 단계:**
1. 큐 크기 설정: read=16, compress=32, send=64
2. 10GB 파일 전송
3. 전송 전체에 걸쳐 피크 메모리 사용량 모니터링

**예상 결과:**
- 메모리가 queue_size × chunk_size로 제한됨
- 피크 메모리 < 50MB 기본 + 큐 메모리
- 전송 중 메모리 사용량 안정적

---

#### TC-PIPE-007: 파이프라인 통계 가용성

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-007 |
| **SRS 추적** | SRS-PIPE-004 |
| **목적** | 파이프라인 통계 사용 가능 여부 검증 |

**테스트 단계:**
1. 파일 전송 시작
2. 전송 중 pipeline_statistics 조회
3. 모든 단계 통계가 채워졌는지 확인
4. 병목 감지 확인

**예상 결과:**
- 단계별 통계 사용 가능 (AC-PIPE-004-1)
- `bottleneck_stage`가 가장 느린 단계 식별 (AC-PIPE-004-2)
- 통계가 실시간으로 업데이트됨 (AC-PIPE-004-3)

---

### 3.5 재개 요구사항 (SRS-RESUME)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-RESUME-001 | 상태 영속화 | T | TC-RESUME-001, TC-RESUME-002 | P1 |
| SRS-RESUME-002 | 전송 재개 | T | TC-RESUME-003, TC-RESUME-004, TC-RESUME-005 | P1 |

#### TC-RESUME-001: 각 청크 후 상태 영속화

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RESUME-001 |
| **SRS 추적** | SRS-RESUME-001 |
| **목적** | 각 청크 후 전송 상태가 영속화되는지 검증 |

**테스트 단계:**
1. 파일 전송 시작 (100개 청크 파일)
2. 50개 청크 후 프로세스 강제 종료
3. 상태 파일 검사
4. chunk_bitmap이 50개 청크 완료를 표시하는지 확인

**예상 결과:**
- 상태 파일 존재 (AC-RESUME-001-2)
- chunk_bitmap이 마지막 완료 청크까지 정확함
- 상태 파일 < 1MB (AC-RESUME-001-3)

---

#### TC-RESUME-002: 상태 파일 크기 제한

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RESUME-002 |
| **SRS 추적** | SRS-RESUME-001 |
| **목적** | 상태 파일 크기가 제한되는지 검증 |

**테스트 단계:**
1. 100GB 파일 전송 (~400,000 청크 생성)
2. 상태 파일 크기 측정
3. 크기가 제한 내에 있는지 확인

**예상 결과:**
- 전송 크기와 관계없이 상태 파일 < 1MB (AC-RESUME-001-3)
- 필요한 모든 메타데이터 보존
- 빠른 상태 파일 로드 시간

---

#### TC-RESUME-003: 프로세스 재시작 후 재개

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RESUME-003 |
| **SRS 추적** | SRS-RESUME-002 |
| **목적** | 프로세스 재시작 후 재개 검증 |

**테스트 단계:**
1. 1GB 파일 전송 시작
2. 50%에서 종료
3. 송신자와 수신자 재시작
4. 전송 재개
5. 완료 확인

**예상 결과:**
- 1초 이내에 재개 시작 (AC-RESUME-002-1)
- 나머지 50%만 전송됨
- 최종 SHA-256 검증 통과 (AC-RESUME-002-2)

---

#### TC-RESUME-004: 네트워크 실패 후 재개

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RESUME-004 |
| **SRS 추적** | SRS-RESUME-002 |
| **목적** | 네트워크 연결 끊김 후 재개 검증 |

**테스트 단계:**
1. 파일 전송 시작
2. 30%에서 네트워크 연결 끊기
3. 10초 후 네트워크 재연결
4. 자동 또는 수동 재개 확인
5. 완료 확인

**예상 결과:**
- 재연결 후 전송 재개 (AC-RESUME-002-3)
- 데이터 손실 또는 손상 없음
- 중복 청크가 올바르게 처리됨

---

#### TC-RESUME-005: 수정된 소스 파일로 재개

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RESUME-005 |
| **SRS 추적** | SRS-RESUME-002 |
| **목적** | 소스 파일 변경 시 재개 실패 검증 |

**테스트 단계:**
1. 파일 전송 시작
2. 50%에서 취소
3. 소스 파일 수정
4. 재개 시도
5. 적절한 오류 확인

**예상 결과:**
- 재개가 오류 코드 -761 (resume_file_changed)로 실패
- 사용자에게 파일 수정 알림
- 새로운 전송 필요

---

### 3.6 진행 상황 모니터링 요구사항 (SRS-PROGRESS)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-PROGRESS-001 | 진행 콜백 | T | TC-PROGRESS-001, TC-PROGRESS-002 | P1 |
| SRS-PROGRESS-002 | 전송 상태 | T, D | TC-PROGRESS-003, TC-PROGRESS-004 | P1 |

#### TC-PROGRESS-001: 진행 콜백 호출

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PROGRESS-001 |
| **SRS 추적** | SRS-PROGRESS-001 |
| **목적** | 진행 콜백이 올바르게 호출되는지 검증 |

**테스트 단계:**
1. 진행 콜백 등록
2. 100MB 파일 전송
3. 콜백 호출 기록
4. 콜백 데이터 정확성 확인

**예상 결과:**
- 콜백이 주기적으로 호출됨 (AC-PROGRESS-001-1)
- `bytes_transferred`가 단조 증가
- `estimated_remaining`이 시간에 따라 감소

---

#### TC-PROGRESS-002: 진행 콜백 비차단

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PROGRESS-002 |
| **SRS 추적** | SRS-PROGRESS-001 |
| **목적** | 느린 콜백이 전송을 차단하지 않는지 검증 |

**테스트 단계:**
1. 100ms 슬립이 있는 콜백 등록
2. 파일 전송
3. 전송 처리량 측정

**예상 결과:**
- 전송 처리량 영향 없음 (AC-PROGRESS-001-3)
- 백로그 시 콜백이 드롭될 수 있음
- 전송이 성공적으로 완료됨

---

#### TC-PROGRESS-003: 전송 상태 전환

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PROGRESS-003 |
| **SRS 추적** | SRS-PROGRESS-002 |
| **목적** | 모든 상태 전환이 보고되는지 검증 |

**테스트 단계:**
1. 상태 변경 콜백 등록
2. 성공적인 전송 완료
3. 상태 순서 확인

**예상 결과:**
- 상태 보고: pending → initializing → transferring → verifying → completed
- 모든 전환이 콜백을 통해 보고됨 (AC-PROGRESS-002-1)
- 최종 상태 항상 보고됨 (AC-PROGRESS-002-3)

---

#### TC-PROGRESS-004: 오류 상태 보고

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PROGRESS-004 |
| **SRS 추적** | SRS-PROGRESS-002 |
| **목적** | 오류 상태에 세부 정보가 포함되는지 검증 |

**테스트 단계:**
1. 전송 실패 유발 (예: 네트워크 연결 끊기)
2. 콜백에서 오류 상태 확인
3. 오류 코드 및 메시지 존재 확인

**예상 결과:**
- 오류 상태 보고 (AC-PROGRESS-002-2)
- 상태에 오류 코드 포함
- 오류 메시지가 설명적임

---

### 3.7 동시 전송 요구사항 (SRS-CONCURRENT)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-CONCURRENT-001 | 다중 전송 | T | TC-CONCURRENT-001, TC-CONCURRENT-002 | P1 |
| SRS-CONCURRENT-002 | 대역폭 조절 | T | TC-CONCURRENT-003, TC-CONCURRENT-004 | P2 |

#### TC-CONCURRENT-001: 100개 동시 전송

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CONCURRENT-001 |
| **SRS 추적** | SRS-CONCURRENT-001, PERF-023 |
| **목적** | 100개 이상 동시 전송 지원 검증 |

**테스트 단계:**
1. 100개 동시 파일 전송 시작 (각 10MB)
2. 시스템 리소스 모니터링
3. 모든 완료 대기
4. 실패 없음 확인

**예상 결과:**
- 100개 전송 모두 완료 (AC-CONCURRENT-001-1)
- 각 전송에 독립적인 진행 상황 (AC-CONCURRENT-001-2)
- 스레드 풀 효율적으로 공유됨 (AC-CONCURRENT-001-3)

---

#### TC-CONCURRENT-002: 독립적인 진행 상황 추적

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CONCURRENT-002 |
| **SRS 추적** | SRS-CONCURRENT-001 |
| **목적** | 각 전송에 독립적인 추적이 있는지 검증 |

**테스트 단계:**
1. 다른 크기의 10개 전송 시작
2. 각 전송에 대해 독립적으로 진행 상황 조회
3. 진행 값이 구별되는지 확인

**예상 결과:**
- 각 transfer_id에 고유한 진행 상황
- 진행 콜백이 올바르게 라우팅됨
- 전송 간 간섭 없음

---

#### TC-CONCURRENT-003: 전역 대역폭 조절

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CONCURRENT-003 |
| **SRS 추적** | SRS-CONCURRENT-002 |
| **목적** | 전역 대역폭 제한 검증 |

**테스트 단계:**
1. 전역 대역폭 제한 = 100 MB/s 설정
2. 10개 동시 전송 시작
3. 총 처리량 측정
4. 제한 허용 오차 내인지 확인

**예상 결과:**
- 총 처리량 ≤ 105 MB/s (5% 허용 오차) (AC-CONCURRENT-002-1)
- 대역폭이 전송 간 공정하게 분배됨

---

#### TC-CONCURRENT-004: 전송별 대역폭 제한

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CONCURRENT-004 |
| **SRS 추적** | SRS-CONCURRENT-002 |
| **목적** | 전송별 대역폭 제한 검증 |

**테스트 단계:**
1. 전송 A 대역폭 = 50 MB/s 설정
2. 전송 B 대역폭 = 무제한 설정
3. 두 전송 동시 실행
4. 개별 처리량 측정

**예상 결과:**
- 전송 A ≤ 52.5 MB/s (5% 허용 오차)
- 전송 B는 최대 사용 가능 대역폭 (AC-CONCURRENT-002-2)
- 제한이 즉시 적용됨 (AC-CONCURRENT-002-3)

---

### 3.8 전송 계층 요구사항 (SRS-TRANS)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-TRANS-001 | 전송 추상화 | T, I | TC-TRANS-001 | P0 |
| SRS-TRANS-002 | TCP 전송 | T | TC-TRANS-002, TC-TRANS-003 | P0 |
| SRS-TRANS-003 | QUIC 전송 | T | TC-TRANS-004, TC-TRANS-005 | P2 |
| SRS-TRANS-004 | 프로토콜 폴백 | T | TC-TRANS-006 | P2 |

#### TC-TRANS-001: 전송 추상화 검증

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-TRANS-001 |
| **SRS 추적** | SRS-TRANS-001 |
| **목적** | 전송 추상화가 프로토콜 전환을 허용하는지 검증 |

**테스트 단계:**
1. 팩토리를 통해 TCP 전송 생성
2. 팩토리를 통해 QUIC 전송 생성 (가능한 경우)
3. 둘 다 `transport_interface` 구현 확인
4. API가 동일한지 확인

**예상 결과:**
- 두 전송 모두 성공적으로 생성됨 (AC-TRANS-001-1)
- 두 프로토콜에 동일한 API 작동
- 전환에 API 변경 불필요

---

#### TC-TRANS-002: TCP + TLS 1.3 전송

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-TRANS-002 |
| **SRS 추적** | SRS-TRANS-002 |
| **목적** | TLS 1.3을 사용한 TCP 전송 검증 |

**테스트 단계:**
1. TLS 활성화로 TCP 전송 설정
2. 연결 수립
3. 파일 전송
4. TLS 1.3 협상 확인

**예상 결과:**
- TLS 1.3 핸드셰이크 성공 (AC-TRANS-002-1)
- 암호화된 데이터 전송
- 인증서 오류 없음

---

#### TC-TRANS-003: TCP_NODELAY 설정

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-TRANS-003 |
| **SRS 추적** | SRS-TRANS-002 |
| **목적** | TCP_NODELAY가 기본적으로 활성화되는지 검증 |

**테스트 단계:**
1. 기본 설정으로 TCP 전송 생성
2. TCP_NODELAY 소켓 옵션 설정 확인
3. 청크 지연시간 측정

**예상 결과:**
- TCP_NODELAY가 기본적으로 활성화됨 (AC-TRANS-002-2)
- 저지연 청크 전송
- Nagle 알고리즘 지연 없음

---

#### TC-TRANS-004: QUIC 0-RTT 연결 (Phase 2)

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-TRANS-004 |
| **SRS 추적** | SRS-TRANS-003 |
| **목적** | QUIC 0-RTT 연결 재개 검증 |

**테스트 단계:**
1. 초기 QUIC 연결 수립
2. 연결 닫기
3. 0-RTT 사용하여 재연결
4. 연결 수립 시간 측정

**예상 결과:**
- 0-RTT 연결 성공 (AC-TRANS-003-1)
- 재연결 시 연결 시간 < 100ms
- 세션 티켓 캐시됨

---

#### TC-TRANS-005: QUIC 멀티스트림 (Phase 2)

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-TRANS-005 |
| **SRS 추적** | SRS-TRANS-003 |
| **목적** | QUIC 멀티스트림 지원 검증 |

**테스트 단계:**
1. max_streams = 10으로 QUIC 설정
2. 10개 동시 스트림 생성
3. 모든 스트림에서 동시에 데이터 전송

**예상 결과:**
- 10개 스트림 모두 기능함 (AC-TRANS-003-2)
- Head-of-line 블로킹 없음
- 총 처리량이 단일 스트림보다 높음

---

#### TC-TRANS-006: QUIC에서 TCP 폴백 (Phase 2)

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-TRANS-006 |
| **SRS 추적** | SRS-TRANS-004 |
| **목적** | 자동 QUIC에서 TCP 폴백 검증 |

**테스트 단계:**
1. QUIC를 기본 전송으로 설정
2. UDP 포트 차단 (방화벽 시뮬레이션)
3. 연결 시도
4. TCP로 폴백 확인

**예상 결과:**
- 5초 이내에 폴백 (AC-TRANS-004-1)
- TCP를 통해 전송 완료 (AC-TRANS-004-2)
- 폴백 이벤트 로깅됨 (AC-TRANS-004-3)

---

### 3.9 성능 요구사항 (PERF)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| PERF-001 | LAN 처리량 | T | TC-PERF-001 | P0 |
| PERF-002 | WAN 처리량 | T | TC-PERF-002 | P1 |
| PERF-003 | LZ4 압축 속도 | T | TC-COMP-001 | P0 |
| PERF-004 | LZ4 해제 속도 | T | TC-COMP-003 | P0 |
| PERF-010 | 청크 처리 지연시간 | T | TC-PERF-003 | P1 |
| PERF-020 | 기본 메모리 | T | TC-PERF-004 | P1 |
| PERF-021 | 전송당 메모리 | T | TC-PERF-005 | P1 |
| PERF-022 | CPU 사용률 | T | TC-PERF-006 | P1 |

#### TC-PERF-001: LAN 처리량 벤치마크

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-001 |
| **SRS 추적** | PERF-001 |
| **목적** | ≥500 MB/s LAN 처리량 검증 |

**테스트 단계:**
1. 동일 LAN에서 송신자와 수신자 설정 (10Gbps)
2. 1GB 파일 전송
3. 전송 시간 측정
4. 처리량 계산

**예상 결과:**
- 처리량 ≥ 500 MB/s
- 전송이 < 2초 내에 완료
- 여러 실행에서 일관됨

---

#### TC-PERF-002: WAN 처리량 테스트

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-002 |
| **SRS 추적** | PERF-002 |
| **목적** | 처리량이 네트워크 용량과 일치하는지 검증 |

**테스트 단계:**
1. WAN을 통해 송신자와 수신자 설정 (시뮬레이션된 100 Mbps)
2. 1GB 파일 전송
3. 처리량 측정

**예상 결과:**
- 처리량 ≥ 네트워크 용량의 90%
- 프로토콜 오버헤드 < 1%

---

#### TC-PERF-003: 청크 처리 지연시간

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-003 |
| **SRS 추적** | PERF-010 |
| **목적** | 청크 처리 지연시간 < 10ms 검증 |

**테스트 단계:**
1. 청크 처리 경로 계측
2. 1000개 청크에 대한 지연시간 측정
3. p99 지연시간 계산

**예상 결과:**
- 평균 지연시간 < 5ms
- p99 지연시간 < 10ms
- 50ms 초과 지연 스파이크 없음

---

#### TC-PERF-004: 기본 메모리 사용량

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-004 |
| **SRS 추적** | PERF-020 |
| **목적** | 기본 메모리 < 50MB 검증 |

**테스트 단계:**
1. file_sender와 file_receiver 시작
2. 유휴 상태 대기
3. RSS 메모리 사용량 측정

**예상 결과:**
- 유휴 상태에서 RSS 메모리 < 50MB
- 유휴 시 메모리 증가 없음

---

#### TC-PERF-005: 전송당 메모리 사용량

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-005 |
| **SRS 추적** | PERF-021 |
| **목적** | 전송당 메모리 < 100MB per 1GB 검증 |

**테스트 단계:**
1. 1GB 파일 전송
2. 전송 중 피크 메모리 모니터링
3. GB당 메모리 계산

**예상 결과:**
- 1GB 전송 중 메모리 사용량 < 100MB
- 전송 완료 후 메모리 해제됨

---

#### TC-PERF-006: CPU 사용률

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-006 |
| **SRS 추적** | PERF-022 |
| **목적** | CPU 사용률 < 코어당 30% 검증 |

**테스트 단계:**
1. 10GB 파일 전송
2. 코어별 CPU 사용률 모니터링
3. 평균 사용률 계산

**예상 결과:**
- 코어당 평균 CPU < 30%
- 지속적으로 100%인 코어 없음
- 효율적인 멀티코어 활용

---

### 3.10 보안 요구사항 (SEC)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SEC-001 | TLS 1.3 암호화 | T, I | TC-SEC-001 | P0 |
| SEC-002 | 인증서 인증 | T | TC-SEC-002 | P1 |
| SEC-003 | 경로 순회 방지 | T | TC-SEC-003 | P0 |
| SEC-004 | 리소스 제한 | T | TC-SEC-004 | P1 |

#### TC-SEC-001: TLS 1.3 암호화 검증

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-SEC-001 |
| **SRS 추적** | SEC-001 |
| **목적** | TLS 1.3 암호화 사용 검증 |

**테스트 단계:**
1. 패킷 캡처 활성화
2. 파일 전송
3. 캡처된 패킷 분석
4. TLS 1.3 핸드셰이크 및 암호화된 페이로드 확인

**예상 결과:**
- TLS 1.3 프로토콜 협상됨
- 모든 데이터 페이로드 암호화됨
- 캡처에서 평문 데이터 보이지 않음

---

#### TC-SEC-002: 인증서 기반 인증

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-SEC-002 |
| **SRS 추적** | SEC-002 |
| **목적** | 인증서 인증 검증 |

**테스트 단계:**
1. 클라이언트 인증서로 송신자 설정
2. 클라이언트 인증 요구하도록 수신자 설정
3. 인증서 없이 전송 시도 → 실패해야 함
4. 유효한 인증서로 전송 시도 → 성공해야 함

**예상 결과:**
- 인증되지 않은 연결 거부됨
- 인증된 연결 성공
- 잘못된 인증서 거부됨

---

#### TC-SEC-003: 경로 순회 방지

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-SEC-003 |
| **SRS 추적** | SEC-003 |
| **목적** | 경로 순회 공격 방지 검증 |

**테스트 단계:**
1. 파일명 `../../../etc/passwd`로 파일 전송
2. 파일명 `/absolute/path/file`로 파일 전송
3. 둘 다 거부되는지 확인

**예상 결과:**
- 경로 순회가 오류 코드 -743으로 차단됨
- 절대 경로 거부됨
- 파일이 설정된 output_directory에만 기록됨

---

#### TC-SEC-004: 리소스 제한 적용

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-SEC-004 |
| **SRS 추적** | SEC-004 |
| **목적** | 리소스 제한 적용 검증 |

**테스트 단계:**
1. max_file_size = 100MB 설정
2. 200MB 파일 전송 시도
3. max_concurrent_transfers = 10 설정
4. 15개 전송 시작 시도

**예상 결과:**
- 크기 초과 파일 거부됨
- 초과 전송이 대기열에 추가되거나 거부됨
- 리소스 고갈 방지됨

---

### 3.11 신뢰성 요구사항 (REL)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| REL-001 | 데이터 무결성 | T | TC-CHUNK-007, TC-CHUNK-008 | P0 |
| REL-002 | 재개 성공률 | T | TC-RESUME-003, TC-RESUME-004 | P1 |
| REL-003 | 오류 복구 | T | TC-REL-001 | P1 |
| REL-004 | 우아한 성능 저하 | T | TC-REL-002 | P2 |

#### TC-REL-001: 지수 백오프를 통한 자동 재시도

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-REL-001 |
| **SRS 추적** | REL-003 |
| **목적** | 지수 백오프를 통한 자동 재시도 검증 |

**테스트 단계:**
1. 처음 3번의 연결 시도를 거부하도록 서버 설정
2. 전송 시도
3. 재시도 동작 모니터링
4. 4번째 시도에서 전송 완료 확인

**예상 결과:**
- 자동 재시도 발생
- 재시도 간 백오프 증가
- 결국 전송 성공

---

#### TC-REL-002: 부하 시 우아한 성능 저하

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-REL-002 |
| **SRS 추적** | REL-004 |
| **목적** | 과부하 시 우아한 성능 저하 검증 |

**테스트 단계:**
1. 200개 동시 전송 시작 (100개 제한 초과)
2. 시스템 동작 모니터링
3. 크래시나 오류 없음 확인

**예상 결과:**
- 시스템이 응답 유지
- 초과 전송이 대기열에 추가되거나 속도 제한됨
- 리소스 고갈로 인한 크래시 없음

---

### 3.12 품질 속성 (MAINT, TEST)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| MAINT-001 | 코드 커버리지 | A | TC-MAINT-001 | P1 |
| MAINT-003 | 코딩 표준 | I | TC-MAINT-002 | P2 |
| TEST-004 | 새니타이저 클린 | T | TC-TEST-001 | P0 |

#### TC-MAINT-001: 코드 커버리지 분석

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-MAINT-001 |
| **SRS 추적** | MAINT-001 |
| **목적** | 코드 커버리지 ≥ 80% 검증 |

**테스트 단계:**
1. 커버리지 계측과 함께 모든 테스트 실행
2. 커버리지 보고서 생성
3. 커버되지 않은 라인 분석

**예상 결과:**
- 라인 커버리지 ≥ 80%
- 브랜치 커버리지 ≥ 70%
- 중요 경로 100% 커버됨

---

#### TC-MAINT-002: 코딩 표준 준수

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-MAINT-002 |
| **SRS 추적** | MAINT-003 |
| **목적** | C++ Core Guidelines 준수 검증 |

**테스트 단계:**
1. cppcoreguidelines 검사로 clang-tidy 실행
2. cppcheck 정적 분석 실행
3. 결과 검토

**예상 결과:**
- 심각한 규칙 위반 없음
- 메모리 안전 문제 없음
- 코드베이스 전체에서 일관된 스타일

---

#### TC-TEST-001: 새니타이저 클린 빌드

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-TEST-001 |
| **SRS 추적** | TEST-004 |
| **목적** | 새니타이저 경고 0건 검증 |

**테스트 단계:**
1. AddressSanitizer로 빌드
2. 모든 테스트 실행
3. ThreadSanitizer로 빌드
4. 모든 테스트 실행

**예상 결과:**
- ASan 오류 0건
- TSan 경고 0건
- UBSan 위반 0건

---

## 4. 검증 일정

### 4.1 1단계: 핵심 인프라 (1-3주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 1 | 빌드 시스템, 기본 구조 | TC-MAINT-001, TC-MAINT-002 |
| 2 | 청크 관리 | TC-CHUNK-001 ~ TC-CHUNK-008 |
| 3 | 핵심 전송 (압축 없음) | TC-CORE-001 ~ TC-CORE-006 |

### 4.2 2단계: LZ4 엔진 (4-5주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 4 | 압축/해제 | TC-COMP-001 ~ TC-COMP-004 |
| 5 | 적응형 감지, 통계 | TC-COMP-005 ~ TC-COMP-009 |

### 4.3 3단계: 파이프라인 및 전송 (6-8주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 6 | 파이프라인 구현 | TC-PIPE-001 ~ TC-PIPE-007 |
| 7 | TCP 전송 | TC-TRANS-001 ~ TC-TRANS-003 |
| 8 | 통합 테스트 | TC-PERF-001 ~ TC-PERF-006 |

### 4.4 4단계: 신뢰성 및 보안 (9-10주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 9 | 재개 기능 | TC-RESUME-001 ~ TC-RESUME-005 |
| 10 | 보안 검증 | TC-SEC-001 ~ TC-SEC-004 |

### 4.5 5단계: 고급 기능 (11-12주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 11 | 동시 전송 | TC-CONCURRENT-001 ~ TC-CONCURRENT-004 |
| 12 | 진행 상황 모니터링 | TC-PROGRESS-001 ~ TC-PROGRESS-004 |

### 4.6 6단계: 최종 검증 (13-14주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 13 | 시스템 통합 | 모든 통합 테스트 |
| 14 | 성능 벤치마크 | 모든 TC-PERF-* 테스트 |

---

## 5. 추적성 요약

### 5.1 요구사항 커버리지

| 카테고리 | 총 요구사항 | 커버됨 | 커버리지 |
|----------|-------------|--------|----------|
| SRS-CORE | 3 | 3 | 100% |
| SRS-CHUNK | 4 | 4 | 100% |
| SRS-COMP | 5 | 5 | 100% |
| SRS-PIPE | 4 | 4 | 100% |
| SRS-RESUME | 2 | 2 | 100% |
| SRS-PROGRESS | 2 | 2 | 100% |
| SRS-CONCURRENT | 2 | 2 | 100% |
| SRS-TRANS | 4 | 4 | 100% |
| PERF | 10 | 10 | 100% |
| SEC | 4 | 4 | 100% |
| REL | 5 | 5 | 100% |
| MAINT/TEST | 5 | 5 | 100% |
| **총합** | **50** | **50** | **100%** |

### 5.2 테스트 케이스 요약

| 카테고리 | 테스트 케이스 | 우선순위 P0 | 우선순위 P1 | 우선순위 P2 |
|----------|--------------|-------------|-------------|-------------|
| 핵심 전송 | 6 | 6 | 0 | 0 |
| 청크 관리 | 8 | 8 | 0 | 0 |
| 압축 | 9 | 5 | 2 | 2 |
| 파이프라인 | 7 | 4 | 3 | 0 |
| 재개 | 5 | 0 | 5 | 0 |
| 진행 상황 | 4 | 0 | 4 | 0 |
| 동시 전송 | 4 | 0 | 2 | 2 |
| 전송 계층 | 6 | 3 | 0 | 3 |
| 성능 | 6 | 2 | 4 | 0 |
| 보안 | 4 | 2 | 2 | 0 |
| 신뢰성 | 2 | 0 | 1 | 1 |
| 유지보수 | 3 | 1 | 1 | 1 |
| **총합** | **64** | **31** | **24** | **9** |

---

## 부록 A: 테스트 데이터 명세

### A.1 표준 테스트 파일

| 이름 | 크기 | 내용 | SHA-256 (처음 8자) |
|------|------|------|---------------------|
| small.txt | 1 KB | "a" 반복 | 2e9b8d3a... |
| medium.bin | 64 KB | 랜덤 바이트 | (생성됨) |
| large.dat | 256 KB | 랜덤 바이트 | (생성됨) |
| text_1mb.log | 1 MB | 로그 파일 형식 | (생성됨) |
| binary_1gb.bin | 1 GB | 랜덤 바이트 | (생성됨) |
| compressed.zip | 10 MB | 이미 압축됨 | (생성됨) |
| image.jpg | 5 MB | JPEG 이미지 | (생성됨) |

### A.2 생성된 테스트 데이터

```cpp
// 테스트 데이터 생성기 의사코드
auto generate_compressible(size_t bytes) {
    // 반복 패턴 생성 (높은 압축률)
    return repeat_pattern("Lorem ipsum dolor sit amet...", bytes);
}

auto generate_random(size_t bytes) {
    // 암호학적 랜덤 바이트 생성 (압축 불가)
    return crypto_random_bytes(bytes);
}

auto generate_mixed(size_t bytes) {
    // 50% 압축 가능, 50% 랜덤
    return concat(generate_compressible(bytes/2), generate_random(bytes/2));
}
```

---

## 부록 B: 검증 도구

### B.1 필수 도구

| 도구 | 용도 | 버전 |
|------|------|------|
| **Google Test** | 단위 테스팅 프레임워크 | 1.12+ |
| **Google Benchmark** | 성능 벤치마킹 | 1.7+ |
| **gcov/llvm-cov** | 코드 커버리지 | 최신 |
| **AddressSanitizer** | 메모리 오류 감지 | 컴파일러 번들 |
| **ThreadSanitizer** | 데이터 레이스 감지 | 컴파일러 번들 |
| **UBSan** | 정의되지 않은 동작 감지 | 컴파일러 번들 |
| **clang-tidy** | 정적 분석 | 14+ |
| **cppcheck** | 정적 분석 | 2.9+ |

### B.2 테스트 자동화

```yaml
# CI 파이프라인 (의사 설정)
stages:
  - build
  - unit_test
  - integration_test
  - benchmark
  - coverage

build:
  script:
    - cmake -B build -DCMAKE_BUILD_TYPE=Debug
    - cmake --build build

unit_test:
  script:
    - ./build/bin/unit_tests
  artifacts:
    - reports/unit_test_results.xml

integration_test:
  script:
    - ./build/bin/integration_tests
  artifacts:
    - reports/integration_test_results.xml

benchmark:
  script:
    - ./build/bin/benchmarks --benchmark_format=json
  artifacts:
    - reports/benchmark_results.json

coverage:
  script:
    - cmake -B build -DENABLE_COVERAGE=ON
    - cmake --build build
    - ./build/bin/unit_tests
    - gcovr --xml -o coverage.xml
  artifacts:
    - coverage.xml
```

---

## 부록 C: 개정 이력

| 버전 | 날짜 | 작성자 | 설명 |
|------|------|--------|------|
| 1.0.0 | 2025-12-11 | kcenon@naver.com | 초기 SVS 작성 |

---

*문서 끝*
