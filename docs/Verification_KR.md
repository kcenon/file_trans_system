# 파일 전송 시스템 - 소프트웨어 검증 명세서

## 문서 정보

| 항목 | 내용 |
|------|------|
| **프로젝트명** | file_trans_system |
| **문서 유형** | 소프트웨어 검증 명세서 (SVS) |
| **버전** | 2.0.0 |
| **상태** | 초안 |
| **작성일** | 2025-12-11 |
| **최종 업데이트** | 2025-12-11 |
| **작성자** | kcenon@naver.com |
| **관련 문서** | SRS_KR.md v2.0.0, SDS_KR.md v2.0.0 |

---

## 1. 소개

### 1.1 목적

본 소프트웨어 검증 명세서(SVS)는 **file_trans_system** 구현이 소프트웨어 요구사항 명세서(SRS)에 명시된 모든 요구사항을 충족하는지 검증하기 위한 접근 방식, 방법 및 테스트 케이스를 정의합니다.

### 1.2 범위

본 문서는 다음을 다룹니다:
- Client-Server 아키텍처 검증 방법론 및 접근 방식
- 업로드/다운로드 작업에 대한 SRS 추적성 있는 테스트 케이스 명세
- 각 요구사항에 대한 인수 조건
- 품질 게이트 및 마일스톤
- 검증 도구 및 환경

### 1.3 검증 방법

| 방법 | 코드 | 설명 |
|------|------|------|
| **검사(Inspection)** | I | 코드 리뷰, 문서 리뷰, 정적 분석 |
| **분석(Analysis)** | A | 수학적 분석, 시뮬레이션, 알고리즘 검증 |
| **시연(Demonstration)** | D | 기능 시연, 워크플로우 검증 |
| **테스트(Test)** | T | 단위 테스트, 통합 테스트, 시스템 테스트, 벤치마크 |

### 1.4 참조 문서

| 문서 | 설명 |
|------|------|
| SRS_KR.md v2.0.0 | 소프트웨어 요구사항 명세서 |
| SDS_KR.md v2.0.0 | 소프트웨어 설계 명세서 |
| IEEE 1012-2016 | 시스템, 소프트웨어 및 하드웨어 V&V 표준 |
| ISO/IEC 29119 | 소프트웨어 테스팅 표준 |

---

## 2. 검증 접근 방식

### 2.1 검증 전략

```
┌─────────────────────────────────────────────────────────────────────┐
│                       검증 계층 구조                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  레벨 4: 시스템 검증                                                 │
│  ├── 종단간 업로드/다운로드 시나리오                                │
│  ├── 다중 클라이언트 동시 작업                                      │
│  ├── 성능 벤치마크                                                   │
│  └── 보안 검증                                                       │
│                                                                      │
│  레벨 3: 통합 검증                                                   │
│  ├── 서버-클라이언트 통합 테스트                                    │
│  ├── 파이프라인 통합 테스트                                          │
│  ├── 자동 재연결 테스트                                              │
│  └── 프로토콜 검증                                                   │
│                                                                      │
│  레벨 2: 컴포넌트 검증                                               │
│  ├── 서버 모듈 단위 테스트                                          │
│  ├── 클라이언트 모듈 단위 테스트                                    │
│  ├── 인터페이스 검증                                                 │
│  └── 오류 처리 테스트                                                │
│                                                                      │
│  레벨 1: 코드 검증                                                   │
│  ├── 정적 분석                                                       │
│  ├── 코드 리뷰                                                       │
│  └── 코딩 표준 준수                                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 테스트 환경

| 구성요소 | 사양 |
|----------|------|
| **OS** | Linux (Ubuntu 22.04+), macOS 11+, Windows 10+ |
| **컴파일러** | GCC 11+, Clang 14+, MSVC 19.29+ |
| **테스트 프레임워크** | Google Test 1.12+, Catch2 3.x |
| **벤치마크** | Google Benchmark 1.7+ |
| **새니타이저** | AddressSanitizer, ThreadSanitizer, UBSan |
| **커버리지** | gcov/llvm-cov 80% 목표 |

### 2.3 품질 게이트

| 게이트 | 조건 | 차단 여부 |
|--------|------|-----------|
| **QG-01** | 모든 단위 테스트 통과 | 예 |
| **QG-02** | 코드 커버리지 ≥ 80% | 예 |
| **QG-03** | AddressSanitizer 오류 0건 | 예 |
| **QG-04** | ThreadSanitizer 경고 0건 | 예 |
| **QG-05** | 모든 통합 테스트 통과 | 예 |
| **QG-06** | 성능 목표 달성 | 예 |
| **QG-07** | API 문서 완료 | 예 |
| **QG-08** | 코드 리뷰 승인 | 예 |

---

## 3. 요구사항 검증 매트릭스

### 3.1 업로드 요구사항 (SRS-UPLOAD)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-UPLOAD-001 | 단일 파일 업로드 | T, D | TC-UPLOAD-001, TC-UPLOAD-002 | P0 |
| SRS-UPLOAD-002 | 업로드 요청 처리 | T, D | TC-UPLOAD-003, TC-UPLOAD-004 | P0 |
| SRS-UPLOAD-003 | 다중 파일 배치 업로드 | T, D | TC-UPLOAD-005, TC-UPLOAD-006 | P0 |

#### TC-UPLOAD-001: 단일 파일 업로드 - 소형 파일

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-UPLOAD-001 |
| **SRS 추적** | SRS-UPLOAD-001 |
| **목적** | 소형 파일에 대한 단일 파일 업로드 검증 |
| **전제조건** | 서버 실행 중, 클라이언트 연결됨 |
| **테스트 데이터** | 알려진 SHA-256을 가진 1KB, 64KB, 256KB 파일 |

**테스트 단계:**
1. 알려진 내용으로 테스트 파일 생성
2. 소스 파일의 SHA-256 해시 계산
3. `client->upload_file()`을 통해 파일 업로드 시작
4. 업로드 완료 대기
5. 서버에 파일이 올바른 SHA-256으로 존재하는지 확인
6. 진행 콜백이 호출되었는지 확인

**예상 결과:**
- 5초 이내에 업로드 완료
- SHA-256 해시 일치
- 진행 콜백 최소 1회 호출
- `transfer_result.verified`가 true

---

#### TC-UPLOAD-002: 단일 파일 업로드 - 대형 파일

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-UPLOAD-002 |
| **SRS 추적** | SRS-UPLOAD-001 |
| **목적** | 대형 파일(1GB+)에 대한 단일 파일 업로드 검증 |
| **전제조건** | 충분한 서버 저장소, 네트워크 대역폭 사용 가능 |
| **테스트 데이터** | 랜덤 내용의 1GB, 10GB 파일 |

**테스트 단계:**
1. 대형 테스트 파일(1GB) 생성
2. 시작 시간 기록
3. 파일 업로드 시작
4. 진행 콜백 모니터링
5. 완료 후 서버에서 파일 무결성 확인
6. 실제 처리량 계산

**예상 결과:**
- 업로드 성공적으로 완료됨
- LAN에서 처리량 ≥ 500 MB/s (PERF-001)
- 업로드 중 메모리 사용량 < 100MB (PERF-021)
- SHA-256 검증 통과

---

#### TC-UPLOAD-003: 업로드 요청 수락/거부

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-UPLOAD-003 |
| **SRS 추적** | SRS-UPLOAD-002 |
| **목적** | 서버 수락/거부 콜백 메커니즘 검증 |
| **전제조건** | 수락 콜백이 등록된 서버 실행 중 |

**테스트 단계:**
1. 100MB 미만 파일에 대해 `true`를 반환하는 서버 콜백 등록
2. 클라이언트가 50MB 파일 업로드 → 수락되어야 함
3. 클라이언트가 200MB 파일 업로드 → 거부되어야 함
4. 거부 오류 코드(-712) 확인

**예상 결과:**
- 50MB 파일 업로드 성공
- 200MB 파일이 오류 코드 -712 (upload_rejected)로 거부됨
- 거부가 적절히 로깅됨

---

#### TC-UPLOAD-004: 저장소 부족 오류 업로드

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-UPLOAD-004 |
| **SRS 추적** | SRS-UPLOAD-002, SRS-STORAGE-002 |
| **목적** | 저장소 부족 오류 처리 검증 |
| **전제조건** | 서버 저장소가 할당량 제한 근처 |

**테스트 단계:**
1. 서버에 100MB 저장소 할당량 설정
2. 총 95MB 파일 업로드
3. 10MB 파일 업로드 시도
4. storage_full 오류 반환 확인

**예상 결과:**
- 오류 코드 -745 (storage_full) 반환
- 서버 안정 유지
- 기존 파일 무결성 유지

---

#### TC-UPLOAD-005: 배치 업로드 - 다중 파일

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-UPLOAD-005 |
| **SRS 추적** | SRS-UPLOAD-003 |
| **목적** | 다중 파일 배치 업로드 검증 |
| **테스트 데이터** | 다양한 크기(1KB ~ 10MB)의 100개 파일 |

**테스트 단계:**
1. 100개 테스트 파일 생성
2. 각 파일의 SHA-256 계산
3. 모든 100개 파일로 `client->upload_files()` 호출
4. 개별 파일 진행 상황 추적
5. 서버에 모든 파일이 올바르게 수신되었는지 확인

**예상 결과:**
- 100개 파일 모두 업로드됨
- 개별 상태 추적 사용 가능
- 배치 진행 상황에 파일별 분석 표시
- 총 시간 < 개별 업로드 합계 (병렬성)

---

#### TC-UPLOAD-006: 배치 업로드 - 부분 실패 복구

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-UPLOAD-006 |
| **SRS 추적** | SRS-UPLOAD-003 |
| **목적** | 단일 파일 실패 후 배치 업로드 계속 검증 |

**테스트 단계:**
1. 10개 파일 배치 생성
2. 서버가 파일 #5를 거부하도록 설정
3. 배치 업로드 시작
4. 나머지 파일이 계속 업로드되는지 확인
5. 최종 상태에서 파일 #5가 실패로 보고되는지 확인

**예상 결과:**
- 파일 1-4 및 6-10 업로드 성공
- 파일 #5가 오류 코드 -712 (upload_rejected) 보고
- 부분 실패가 배치를 중단하지 않음

---

### 3.2 다운로드 요구사항 (SRS-DOWNLOAD)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-DOWNLOAD-001 | 단일 파일 다운로드 | T, D | TC-DOWNLOAD-001, TC-DOWNLOAD-002 | P0 |
| SRS-DOWNLOAD-002 | 다운로드 요청 처리 | T | TC-DOWNLOAD-003, TC-DOWNLOAD-004 | P0 |
| SRS-DOWNLOAD-003 | 다중 파일 배치 다운로드 | T | TC-DOWNLOAD-005 | P1 |

#### TC-DOWNLOAD-001: 단일 파일 다운로드 - 소형 파일

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-DOWNLOAD-001 |
| **SRS 추적** | SRS-DOWNLOAD-001 |
| **목적** | 소형 파일에 대한 단일 파일 다운로드 검증 |
| **전제조건** | 서버에 파일 저장됨, 클라이언트 연결됨 |
| **테스트 데이터** | 서버에 있는 1KB, 64KB, 256KB 파일 |

**테스트 단계:**
1. 서버에 테스트 파일이 존재하는지 확인
2. `client->download_file()`을 통해 파일 다운로드 시작
3. 다운로드 완료 대기
4. 다운로드된 파일 SHA-256이 서버 파일과 일치하는지 확인
5. 진행 콜백이 호출되었는지 확인

**예상 결과:**
- 5초 이내에 다운로드 완료
- SHA-256 해시 일치
- 진행 콜백 최소 1회 호출
- `transfer_result.verified`가 true

---

#### TC-DOWNLOAD-002: 단일 파일 다운로드 - 대형 파일

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-DOWNLOAD-002 |
| **SRS 추적** | SRS-DOWNLOAD-001 |
| **목적** | 대형 파일(1GB+)에 대한 단일 파일 다운로드 검증 |
| **전제조건** | 서버에 대형 파일 있음, 클라이언트에 충분한 디스크 공간 |
| **테스트 데이터** | 서버에 있는 1GB, 10GB 파일 |

**테스트 단계:**
1. 서버에 대형 테스트 파일이 존재하는지 확인
2. 시작 시간 기록
3. 파일 다운로드 시작
4. 진행 콜백 모니터링
5. 완료 후 파일 무결성 확인
6. 실제 처리량 계산

**예상 결과:**
- 다운로드 성공적으로 완료됨
- LAN에서 처리량 ≥ 500 MB/s
- 다운로드 중 메모리 사용량 < 100MB
- SHA-256 검증 통과

---

#### TC-DOWNLOAD-003: 다운로드 - 파일 없음

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-DOWNLOAD-003 |
| **SRS 추적** | SRS-DOWNLOAD-002 |
| **목적** | 파일 없음 오류 처리 검증 |
| **전제조건** | 서버 실행 중, 파일이 존재하지 않음 |

**테스트 단계:**
1. 존재하지 않는 파일 "nosuchfile.dat" 다운로드 시도
2. 적절한 오류 반환 확인
3. 클라이언트 안정 유지 확인

**예상 결과:**
- 오류 코드 -746 (file_not_found_on_server) 반환
- 명확한 오류 메시지
- 부분 파일 생성되지 않음

---

#### TC-DOWNLOAD-004: 다운로드 요청 수락/거부

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-DOWNLOAD-004 |
| **SRS 추적** | SRS-DOWNLOAD-002 |
| **목적** | 서버가 다운로드 요청을 거부할 수 있는지 검증 |
| **전제조건** | 다운로드 필터 콜백이 있는 서버 |

**테스트 단계:**
1. "*.confidential" 파일을 거부하는 다운로드 콜백 등록
2. 클라이언트가 "report.txt" 다운로드 → 성공해야 함
3. 클라이언트가 "secrets.confidential" 다운로드 → 거부되어야 함
4. 거부 오류 확인

**예상 결과:**
- 일반 파일 다운로드 성공
- 기밀 파일 오류 코드 -747 (access_denied)로 거부됨

---

#### TC-DOWNLOAD-005: 배치 다운로드 - 다중 파일

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-DOWNLOAD-005 |
| **SRS 추적** | SRS-DOWNLOAD-003 |
| **목적** | 다중 파일 배치 다운로드 검증 |
| **테스트 데이터** | 서버에 있는 50개 파일 |

**테스트 단계:**
1. 서버에 50개 파일이 존재하는지 확인
2. 모든 50개 파일로 `client->download_files()` 호출
3. 개별 파일 진행 상황 추적
4. 모든 파일이 올바르게 다운로드되었는지 확인

**예상 결과:**
- 50개 파일 모두 다운로드됨
- 개별 상태 추적 사용 가능
- 모든 파일에 대해 SHA-256 검증 통과

---

### 3.3 파일 목록 요구사항 (SRS-LIST)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-LIST-001 | 파일 목록 조회 | T, D | TC-LIST-001, TC-LIST-002 | P1 |

#### TC-LIST-001: 모든 파일 목록 조회

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-LIST-001 |
| **SRS 추적** | SRS-LIST-001 |
| **목적** | 파일 목록이 모든 파일을 반환하는지 검증 |
| **전제조건** | 알려진 파일 집합이 있는 서버 |

**테스트 단계:**
1. 서버에 10개의 알려진 파일 업로드
2. `client->list_files()` 호출
3. 결과에 10개 파일 모두 있는지 확인
4. 메타데이터(파일명, 크기, 수정 시간) 확인

**예상 결과:**
- 10개 파일 모두 나열됨
- 각 파일에 대한 메타데이터 정확함
- 응답 시간 < 1초

---

#### TC-LIST-002: 패턴 필터로 파일 목록 조회

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-LIST-002 |
| **SRS 추적** | SRS-LIST-001 |
| **목적** | 패턴 필터링 작동 검증 |
| **전제조건** | 혼합된 파일 유형이 있는 서버 |

**테스트 단계:**
1. 서버에 .txt 파일 5개와 .log 파일 5개 업로드
2. `client->list_files("*.txt")` 호출
3. .txt 파일만 반환되는지 확인
4. `client->list_files("*.log")` 호출
5. .log 파일만 반환되는지 확인

**예상 결과:**
- 패턴 필터가 올바르게 적용됨
- 일치하는 파일만 반환됨
- 오탐 또는 미탐 없음

---

### 3.4 자동 재연결 요구사항 (SRS-RECONNECT)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-RECONNECT-001 | 자동 재연결 활성화 | T | TC-RECONNECT-001, TC-RECONNECT-002 | P0 |
| SRS-RECONNECT-002 | 재연결 정책 | T | TC-RECONNECT-003, TC-RECONNECT-004 | P0 |

#### TC-RECONNECT-001: 유휴 상태 자동 재연결

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RECONNECT-001 |
| **SRS 추적** | SRS-RECONNECT-001 |
| **목적** | 전송이 활성화되지 않은 상태에서 자동 재연결 검증 |
| **전제조건** | auto_reconnect 활성화된 클라이언트 연결됨 |

**테스트 단계:**
1. auto_reconnect = true로 클라이언트 연결
2. 네트워크 연결 끊기 (실패 시뮬레이션)
3. on_reconnecting 콜백 호출 확인
4. 네트워크 복원
5. on_reconnected 콜백 호출 확인
6. 클라이언트가 작업을 수행할 수 있는지 확인

**예상 결과:**
- 재연결이 자동으로 시도됨
- 콜백이 올바르게 호출됨
- 재연결 후 작업 정상 동작

---

#### TC-RECONNECT-002: 자동 재연결 비활성화

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RECONNECT-002 |
| **SRS 추적** | SRS-RECONNECT-001 |
| **목적** | 자동 재연결을 비활성화할 수 있는지 검증 |
| **전제조건** | auto_reconnect 비활성화된 클라이언트 연결됨 |

**테스트 단계:**
1. auto_reconnect = false로 클라이언트 연결
2. 네트워크 연결 끊기
3. 재연결 시도가 없는지 확인
4. on_disconnected 콜백 호출 확인

**예상 결과:**
- 재연결 시도 없음
- 클라이언트가 연결 끊김 상태로 진입
- 사용자가 수동으로 재연결해야 함

---

#### TC-RECONNECT-003: 지수 백오프 정책

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RECONNECT-003 |
| **SRS 추적** | SRS-RECONNECT-002 |
| **목적** | 지수 백오프 타이밍 검증 |
| **전제조건** | reconnect_policy가 설정된 클라이언트 |

**테스트 단계:**
1. 정책 설정: initial_delay=1s, multiplier=2.0, max_delay=30s
2. 네트워크 연결 끊기 (계속 끊긴 상태 유지)
3. 재연결 시도 간 시간 기록
4. 지연이 최대값까지 두 배씩 증가하는지 확인

**예상 결과:**
- 시도 1: ~1s 지연
- 시도 2: ~2s 지연
- 시도 3: ~4s 지연
- 최대 30s로 제한됨

---

#### TC-RECONNECT-004: 최대 시도 횟수 제한

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RECONNECT-004 |
| **SRS 추적** | SRS-RECONNECT-002 |
| **목적** | max_attempts가 준수되는지 검증 |
| **전제조건** | max_attempts = 5인 클라이언트 |

**테스트 단계:**
1. max_attempts = 5 설정
2. 네트워크 연결 끊기 (계속 끊긴 상태 유지)
3. 재연결 시도 횟수 카운트
4. 5번 시도 후 중지 확인

**예상 결과:**
- 정확히 5번의 재연결 시도
- 마지막 시도 후 on_reconnect_failed 콜백 호출
- 클라이언트가 최종 연결 끊김 상태로 진입

---

### 3.5 저장소 관리 요구사항 (SRS-STORAGE)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-STORAGE-001 | 저장소 디렉토리 | T | TC-STORAGE-001 | P0 |
| SRS-STORAGE-002 | 저장소 할당량 | T | TC-STORAGE-002, TC-STORAGE-003 | P0 |

#### TC-STORAGE-001: 저장소 디렉토리 설정

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-STORAGE-001 |
| **SRS 추적** | SRS-STORAGE-001 |
| **목적** | 저장소 디렉토리 설정 검증 |

**테스트 단계:**
1. storage_directory = "/data/files"로 서버 설정
2. 서버 시작
3. 파일 업로드
4. /data/files/에 파일이 생성되었는지 확인

**예상 결과:**
- /data/files/uploaded_file.dat에 파일 존재
- 저장소 디렉토리 외부에 파일 없음
- 존재하지 않으면 디렉토리 생성됨

---

#### TC-STORAGE-002: 저장소 할당량 적용

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-STORAGE-002 |
| **SRS 추적** | SRS-STORAGE-002 |
| **목적** | 저장소 할당량이 적용되는지 검증 |

**테스트 단계:**
1. storage_quota = 100MB로 서버 설정
2. 50MB 파일 업로드 → 성공
3. 40MB 파일 업로드 → 성공 (총 90MB)
4. 20MB 파일 업로드 → 실패해야 함 (100MB 초과)

**예상 결과:**
- 처음 두 업로드 성공
- 세 번째 업로드 오류 코드 -745 (storage_full)로 실패
- 서버 통계에 90MB 사용 표시

---

#### TC-STORAGE-003: 저장소 통계 정확성

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-STORAGE-003 |
| **SRS 추적** | SRS-STORAGE-002 |
| **목적** | 저장소 통계가 정확한지 검증 |

**테스트 단계:**
1. 빈 저장소로 서버 시작
2. storage_stats 조회 → 0 바이트 사용
3. 10MB 파일 업로드
4. storage_stats 조회 → ~10MB 사용
5. 파일 삭제 (지원되는 경우) 또는 재시작
6. 통계가 변경 사항을 반영하는지 확인

**예상 결과:**
- bytes_used 정확함
- file_count 정확함
- bytes_available 정확함
- 실시간 업데이트

---

### 3.6 청크 관리 요구사항 (SRS-CHUNK)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-CHUNK-001 | 파일 분할 | T, A | TC-CHUNK-001, TC-CHUNK-002 | P0 |
| SRS-CHUNK-002 | 파일 조립 | T | TC-CHUNK-003, TC-CHUNK-004 | P0 |
| SRS-CHUNK-003 | 청크 체크섬 | T | TC-CHUNK-005, TC-CHUNK-006 | P0 |
| SRS-CHUNK-004 | 파일 해시 검증 | T | TC-CHUNK-007, TC-CHUNK-008 | P0 |

#### TC-CHUNK-001: 청크 크기 설정

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-001 |
| **SRS 추적** | SRS-CHUNK-001 |
| **목적** | 설정 가능한 청크 크기 검증 |

**테스트 단계:**
1. chunk_size = 64KB (최소값) 설정
2. 1MB 파일 업로드 → 16개 청크 생성 확인
3. chunk_size = 1MB (최대값) 설정
4. 1MB 파일 업로드 → 1개 청크 생성 확인
5. chunk_size = 32KB (최소값 미만) 설정 → 오류 확인

**예상 결과:**
- 64KB 청크: 정확히 16개 청크
- 1MB 청크: 정확히 1개 청크
- 유효하지 않은 크기는 오류 코드 -791 (config_chunk_size_error) 반환

---

#### TC-CHUNK-002: 마지막 청크 처리

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-002 |
| **SRS 추적** | SRS-CHUNK-001 |
| **목적** | 마지막 청크 크기 처리 검증 |

**테스트 단계:**
1. chunk_size = 256KB 설정
2. 600KB (2.34 청크) 크기 파일 업로드
3. 처음 2개 청크가 각각 256KB인지 확인
4. 마지막 청크가 88KB인지 확인
5. 청크 #3에 last_chunk 플래그 설정 확인

**예상 결과:**
- 마지막 청크 크기 = 88KB (< chunk_size)
- 마지막 청크에 `chunk_flags::last_chunk` 설정
- 파일이 올바르게 재구성됨

---

#### TC-CHUNK-003: 순서가 뒤바뀐 청크 조립

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-003 |
| **SRS 추적** | SRS-CHUNK-002 |
| **목적** | 순서가 뒤바뀐 청크 재조립 검증 |

**테스트 단계:**
1. 10개 청크로 파일 업로드
2. 인위적 지연을 주입하여 청크 순서 변경 (3,1,5,2,4,7,6,8,10,9)
3. 순차적 쓰기가 가능할 때까지 청크 버퍼링 확인
4. 최종 파일 무결성 확인

**예상 결과:**
- 청크가 올바르게 재조립됨
- 데이터 손상 없음
- SHA-256 검증 통과

---

#### TC-CHUNK-004: 중복 청크 처리

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-004 |
| **SRS 추적** | SRS-CHUNK-002 |
| **목적** | 중복 청크가 멱등성 있게 처리되는지 검증 |

**테스트 단계:**
1. 5개 청크로 파일 업로드
2. 청크 #3을 두 번 전송 (테스트 후크 통해)
3. 중복이 무시되는지 확인
4. 파일이 올바르게 조립되는지 확인

**예상 결과:**
- 중복 청크가 오류 없이 무시됨
- 파일 무결성 유지
- 출력 파일에 중복 데이터 없음

---

#### TC-CHUNK-005: CRC32 계산 성능

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-005 |
| **SRS 추적** | SRS-CHUNK-003 |
| **목적** | CRC32 오버헤드가 최소인지 검증 |

**테스트 단계:**
1. 256KB 청크에 대한 CRC32 계산 벤치마크
2. CRC32 유무에 따른 시간 측정
3. 오버헤드 비율 계산

**예상 결과:**
- CRC32 오버헤드 < 전송 시간의 1%
- CRC32 처리량 > 5 GB/s

---

#### TC-CHUNK-006: CRC32 손상 감지

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-006 |
| **SRS 추적** | SRS-CHUNK-003 |
| **목적** | CRC32가 단일 비트 오류를 감지하는지 검증 |

**테스트 단계:**
1. 알려진 CRC32를 가진 청크 생성
2. 청크 데이터에서 단일 비트 반전
3. CRC32 불일치 감지 확인
4. 오류 코드 -720 반환 확인

**예상 결과:**
- 단일 비트 오류 감지
- 오류 코드 -720 (chunk_checksum_error) 반환
- 손상된 청크 거부됨

---

#### TC-CHUNK-007: SHA-256 파일 검증

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-007 |
| **SRS 추적** | SRS-CHUNK-004 |
| **목적** | SHA-256이 올바르게 계산되고 검증되는지 검증 |

**테스트 단계:**
1. 소스 파일의 SHA-256 계산
2. 파일 업로드
3. SHA-256이 transfer_result에 포함되는지 확인
4. 소스 파일 해시와 비교

**예상 결과:**
- 업로드 전 SHA-256 계산
- 다운로드 후 SHA-256 검증
- transfer_result에 해시 포함
- 해시 일치

---

#### TC-CHUNK-008: SHA-256 불일치 감지

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CHUNK-008 |
| **SRS 추적** | SRS-CHUNK-004 |
| **목적** | SHA-256 불일치가 감지되는지 검증 |

**테스트 단계:**
1. 파일 업로드 시작
2. 검증 전 서버에서 수신된 파일 손상 (테스트 후크 통해)
3. SHA-256 불일치 감지 확인
4. 오류 코드 -723 반환 확인

**예상 결과:**
- 해시 불일치 감지
- 오류 코드 -723 (file_hash_mismatch) 반환
- 전송이 실패로 표시됨

---

### 3.7 압축 요구사항 (SRS-COMP)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-COMP-001 | LZ4 압축 | T, A | TC-COMP-001, TC-COMP-002 | P0 |
| SRS-COMP-002 | LZ4 해제 | T | TC-COMP-003, TC-COMP-004 | P0 |
| SRS-COMP-003 | 적응형 감지 | T | TC-COMP-005, TC-COMP-006 | P1 |
| SRS-COMP-004 | 압축 모드 설정 | T | TC-COMP-007, TC-COMP-008 | P0 |
| SRS-COMP-005 | 압축 통계 | T | TC-COMP-009 | P2 |

#### TC-COMP-001: LZ4 압축 속도 벤치마크

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-001 |
| **SRS 추적** | SRS-COMP-001, PERF-003 |
| **목적** | LZ4 압축 속도가 목표를 충족하는지 검증 |

**테스트 단계:**
1. 100MB 압축 가능한 테스트 데이터 생성 (텍스트)
2. LZ4 압축 10회 반복 실행
3. 평균 처리량 계산
4. 압축률 기록

**예상 결과:**
- 압축 속도 ≥ 400 MB/s
- 텍스트 데이터에 대해 압축률 ≥ 2.0:1

---

#### TC-COMP-002: LZ4-HC 고압축 모드

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-002 |
| **SRS 추적** | SRS-COMP-001 |
| **목적** | LZ4-HC 압축 특성 검증 |

**테스트 단계:**
1. LZ4 표준으로 100MB 파일 압축
2. LZ4-HC (레벨 9)로 동일 파일 압축
3. 압축률 비교
4. 해제가 동일한 출력을 생성하는지 확인

**예상 결과:**
- LZ4-HC 비율 > LZ4 표준 비율
- LZ4-HC 압축 속도 ≥ 50 MB/s
- 둘 다 동일한 원본 데이터로 해제됨

---

#### TC-COMP-003: LZ4 해제 속도 벤치마크

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-003 |
| **SRS 추적** | SRS-COMP-002, PERF-004 |
| **목적** | LZ4 해제 속도가 목표를 충족하는지 검증 |

**테스트 단계:**
1. 100MB 테스트 데이터 압축
2. 해제 10회 반복 실행
3. 평균 처리량 계산
4. 해제된 데이터 무결성 확인

**예상 결과:**
- 해제 속도 ≥ 1.5 GB/s
- 해제된 데이터가 원본과 정확히 일치

---

#### TC-COMP-004: 해제 오류 처리

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-004 |
| **SRS 추적** | SRS-COMP-002 |
| **목적** | 해제 오류 처리 검증 |

**테스트 단계:**
1. 손상된 압축 데이터 생성
2. 해제 시도
3. 적절한 오류 반환 확인

**예상 결과:**
- 유효하지 않은 데이터는 오류 코드 -781 (decompression_failed) 반환
- 크래시나 정의되지 않은 동작 없음

---

#### TC-COMP-005: 적응형 압축 - 압축 가능한 데이터

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-005 |
| **SRS 추적** | SRS-COMP-003 |
| **목적** | 압축 가능한 데이터에 대한 적응형 감지 검증 |

**테스트 단계:**
1. 텍스트 파일 생성 (높은 압축률)
2. 적응형 압축 모드 활성화
3. 파일 업로드
4. 압축이 적용되었는지 확인

**예상 결과:**
- 텍스트 파일이 압축 가능으로 감지됨
- 압축 적용됨
- 감지 시간 < 100μs

---

#### TC-COMP-006: 적응형 압축 - 압축 불가능한 데이터

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-006 |
| **SRS 추적** | SRS-COMP-003 |
| **목적** | 압축 불가능한 데이터에 대한 적응형 감지 검증 |

**테스트 단계:**
1. 이미 압축된 파일 생성 또는 사용 (ZIP, JPEG)
2. 적응형 압축 모드 활성화
3. 파일 업로드
4. 압축이 건너뛰어졌는지 확인

**예상 결과:**
- 압축된 파일이 압축 불가능으로 감지됨
- 압축 건너뛰어짐 (chunks_skipped 증가)
- 이중 압축 오버헤드 없음

---

#### TC-COMP-007: 압축 모드 - 비활성화

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-007 |
| **SRS 추적** | SRS-COMP-004 |
| **목적** | 비활성화된 압축 모드 검증 |

**테스트 단계:**
1. compression_mode = disabled 설정
2. 압축 가능한 파일 업로드
3. 원시 데이터가 전송되었는지 확인 (압축 플래그 없음)

**예상 결과:**
- 압축 적용 안 됨
- `chunk_flags::compressed` 설정 안 됨
- bytes_transferred == bytes_on_wire

---

#### TC-COMP-008: 압축 모드 - 활성화

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-008 |
| **SRS 추적** | SRS-COMP-004 |
| **목적** | 활성화된 압축 모드 검증 |

**테스트 단계:**
1. compression_mode = enabled 설정
2. 이미 압축된 파일 업로드 (ZIP)
3. 비효율적이더라도 압축이 적용되었는지 확인

**예상 결과:**
- 압축 항상 적용
- 모든 청크에 `chunk_flags::compressed` 설정
- bytes_on_wire > bytes_transferred일 수 있음

---

#### TC-COMP-009: 압축 통계 정확성

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-COMP-009 |
| **SRS 추적** | SRS-COMP-005 |
| **목적** | 압축 통계 정확성 검증 |

**테스트 단계:**
1. 혼합 배치 업로드 (텍스트 파일 5개, 바이너리 파일 5개)
2. compression_statistics 조회
3. 통계가 실제 동작과 일치하는지 확인

**예상 결과:**
- `total_raw_bytes`가 파일 크기 합계와 일치
- `compression_ratio`가 정확함
- `chunks_compressed` + `chunks_skipped` = 총 청크
- 통계가 실시간으로 사용 가능

---

### 3.8 파이프라인 요구사항 (SRS-PIPE)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-PIPE-001 | 업로드 파이프라인 | T, D | TC-PIPE-001, TC-PIPE-002 | P0 |
| SRS-PIPE-002 | 다운로드 파이프라인 | T, D | TC-PIPE-003, TC-PIPE-004 | P0 |
| SRS-PIPE-003 | 파이프라인 백프레셔 | T | TC-PIPE-005, TC-PIPE-006 | P1 |
| SRS-PIPE-004 | 파이프라인 통계 | T, D | TC-PIPE-007 | P1 |

#### TC-PIPE-001: 업로드 파이프라인 동시성

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-001 |
| **SRS 추적** | SRS-PIPE-001 |
| **목적** | 업로드 파이프라인 단계가 동시에 실행되는지 검증 |

**테스트 단계:**
1. 파이프라인 단계에 타이밍 마커 계측
2. 대형 파일(1GB) 업로드
3. 단계 간 타이밍 중첩 분석
4. 5개 단계 모두 병렬로 실행되는지 확인

**예상 결과:**
- 모든 단계 (read, chunk, compress, send, ack)가 중첩됨
- 파이프라인 처리량 > 단일 스레드 처리량
- 단계 기아 없음

---

#### TC-PIPE-002: 업로드 파이프라인 워커 설정

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-002 |
| **SRS 추적** | SRS-PIPE-001 |
| **목적** | 파이프라인 워커 설정 검증 |

**테스트 단계:**
1. io_read workers = 4 (기본값 아님) 설정
2. compression workers = 8 설정
3. 파일 업로드 및 통계에서 워커 수 확인
4. 설정이 적용되었는지 확인

**예상 결과:**
- 사용자 정의 워커 수 적용됨
- 통계에 올바른 워커 사용률 표시
- 리소스 경합 문제 없음

---

#### TC-PIPE-003: 다운로드 파이프라인 동시성

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-003 |
| **SRS 추적** | SRS-PIPE-002 |
| **목적** | 다운로드 파이프라인 단계가 동시에 실행되는지 검증 |

**테스트 단계:**
1. 다운로드 파이프라인 단계 계측
2. 대형 파일(1GB) 다운로드
3. 5개 단계 모두 병렬로 실행되는지 확인

**예상 결과:**
- 모든 단계 (recv, decompress, assemble, write, ack)가 중첩됨
- 순서가 뒤바뀐 청크가 올바르게 처리됨

---

#### TC-PIPE-004: 다운로드 파이프라인 설정

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-004 |
| **SRS 추적** | SRS-PIPE-002 |
| **목적** | 다운로드 파이프라인 워커 설정 검증 |

**테스트 단계:**
1. 사용자 정의 워커 수 설정
2. 파일 다운로드
3. 설정이 적용되었는지 확인

**예상 결과:**
- 워커 수 설정 가능
- 워커 수에 따라 성능 확장 (한계까지)

---

#### TC-PIPE-005: 백프레셔 - 느린 소비자

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-005 |
| **SRS 추적** | SRS-PIPE-003 |
| **목적** | 소비자가 느릴 때 백프레셔 검증 |

**테스트 단계:**
1. write_queue_size = 4 (작게) 설정
2. 파일 쓰기 단계를 인위적으로 느리게 함
3. 대형 파일 다운로드
4. 메모리 사용량 및 큐 깊이 모니터링

**예상 결과:**
- 업스트림 단계가 느려짐
- 메모리 사용량이 제한됨
- 파일 크기와 관계없이 OOM 상황 없음

---

#### TC-PIPE-006: 백프레셔 - 메모리 제한

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-006 |
| **SRS 추적** | SRS-PIPE-003 |
| **목적** | 전송 중 메모리가 제한되는지 검증 |

**테스트 단계:**
1. 큐 크기 설정: read=16, compress=32, send=64
2. 10GB 파일 업로드
3. 전송 전체에 걸쳐 피크 메모리 사용량 모니터링

**예상 결과:**
- 메모리가 queue_size × chunk_size로 제한됨
- 피크 메모리 < 50MB 기본 + 큐 메모리
- 전송 중 메모리 사용량 안정적

---

#### TC-PIPE-007: 파이프라인 통계 가용성

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PIPE-007 |
| **SRS 추적** | SRS-PIPE-004 |
| **목적** | 파이프라인 통계 사용 가능 여부 검증 |

**테스트 단계:**
1. 파일 업로드 시작
2. 업로드 중 pipeline_statistics 조회
3. 모든 단계 통계가 채워졌는지 확인
4. 병목 감지 확인

**예상 결과:**
- 단계별 통계 사용 가능
- `bottleneck_stage`가 가장 느린 단계 식별
- 통계가 실시간으로 업데이트됨

---

### 3.9 재개 요구사항 (SRS-RESUME)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-RESUME-001 | 상태 영속화 | T | TC-RESUME-001, TC-RESUME-002 | P1 |
| SRS-RESUME-002 | 전송 재개 | T | TC-RESUME-003, TC-RESUME-004, TC-RESUME-005 | P1 |

#### TC-RESUME-001: 각 청크 후 상태 영속화

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RESUME-001 |
| **SRS 추적** | SRS-RESUME-001 |
| **목적** | 각 청크 후 전송 상태가 영속화되는지 검증 |

**테스트 단계:**
1. 파일 업로드 시작 (100개 청크 파일)
2. 50개 청크 후 클라이언트 프로세스 강제 종료
3. 상태 파일 검사
4. chunk_bitmap이 50개 청크 완료를 표시하는지 확인

**예상 결과:**
- 상태 파일 존재
- chunk_bitmap이 마지막 완료 청크까지 정확함
- 상태 파일 < 1MB

---

#### TC-RESUME-002: 상태 파일 크기 제한

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RESUME-002 |
| **SRS 추적** | SRS-RESUME-001 |
| **목적** | 상태 파일 크기가 제한되는지 검증 |

**테스트 단계:**
1. 100GB 파일 업로드 (~400,000 청크 생성)
2. 상태 파일 크기 측정
3. 크기가 제한 내에 있는지 확인

**예상 결과:**
- 전송 크기와 관계없이 상태 파일 < 1MB
- 필요한 모든 메타데이터 보존
- 빠른 상태 파일 로드 시간

---

#### TC-RESUME-003: 클라이언트 재시작 후 재개

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RESUME-003 |
| **SRS 추적** | SRS-RESUME-002 |
| **목적** | 클라이언트 재시작 후 재개 검증 |

**테스트 단계:**
1. 1GB 파일 업로드 시작
2. 50%에서 클라이언트 종료
3. 클라이언트 재시작 및 재연결
4. 업로드 재개
5. 완료 확인

**예상 결과:**
- 1초 이내에 재개 시작
- 나머지 50%만 업로드됨
- 최종 SHA-256 검증 통과

---

#### TC-RESUME-004: 네트워크 실패 후 재개

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RESUME-004 |
| **SRS 추적** | SRS-RESUME-002 |
| **목적** | 네트워크 연결 끊김 후 재개 검증 |

**테스트 단계:**
1. 파일 업로드 시작
2. 30%에서 네트워크 연결 끊기
3. 네트워크 재연결 (auto-reconnect 사용)
4. 자동 재개 확인
5. 완료 확인

**예상 결과:**
- 재연결 후 전송 재개
- 데이터 손실 또는 손상 없음
- 중복 청크가 올바르게 처리됨

---

#### TC-RESUME-005: 수정된 소스 파일로 재개

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-RESUME-005 |
| **SRS 추적** | SRS-RESUME-002 |
| **목적** | 소스 파일 변경 시 재개 실패 검증 |

**테스트 단계:**
1. 파일 업로드 시작
2. 50%에서 취소
3. 소스 파일 수정
4. 재개 시도
5. 적절한 오류 확인

**예상 결과:**
- 재개가 오류 코드 -761 (resume_file_changed)로 실패
- 사용자에게 파일 수정 알림
- 새로운 업로드 필요

---

### 3.10 진행 상황 모니터링 요구사항 (SRS-PROGRESS)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-PROGRESS-001 | 진행 콜백 | T | TC-PROGRESS-001, TC-PROGRESS-002 | P1 |
| SRS-PROGRESS-002 | 전송 상태 | T, D | TC-PROGRESS-003, TC-PROGRESS-004 | P1 |

#### TC-PROGRESS-001: 진행 콜백 호출

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PROGRESS-001 |
| **SRS 추적** | SRS-PROGRESS-001 |
| **목적** | 진행 콜백이 올바르게 호출되는지 검증 |

**테스트 단계:**
1. 진행 콜백 등록
2. 100MB 파일 업로드
3. 콜백 호출 기록
4. 콜백 데이터 정확성 확인

**예상 결과:**
- 콜백이 주기적으로 호출됨
- `bytes_transferred`가 단조 증가
- `estimated_remaining`이 시간에 따라 감소

---

#### TC-PROGRESS-002: 진행 콜백 비차단

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PROGRESS-002 |
| **SRS 추적** | SRS-PROGRESS-001 |
| **목적** | 느린 콜백이 전송을 차단하지 않는지 검증 |

**테스트 단계:**
1. 100ms 슬립이 있는 콜백 등록
2. 파일 업로드
3. 전송 처리량 측정

**예상 결과:**
- 전송 처리량 영향 없음
- 백로그 시 콜백이 드롭될 수 있음
- 전송이 성공적으로 완료됨

---

#### TC-PROGRESS-003: 전송 상태 전환

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PROGRESS-003 |
| **SRS 추적** | SRS-PROGRESS-002 |
| **목적** | 모든 상태 전환이 보고되는지 검증 |

**테스트 단계:**
1. 상태 변경 콜백 등록
2. 성공적인 업로드 완료
3. 상태 순서 확인

**예상 결과:**
- 상태 보고: pending → initializing → transferring → verifying → completed
- 모든 전환이 콜백을 통해 보고됨
- 최종 상태 항상 보고됨

---

#### TC-PROGRESS-004: 오류 상태 보고

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PROGRESS-004 |
| **SRS 추적** | SRS-PROGRESS-002 |
| **목적** | 오류 상태에 세부 정보가 포함되는지 검증 |

**테스트 단계:**
1. 전송 실패 유발 (예: 네트워크 연결 끊기)
2. 콜백에서 오류 상태 확인
3. 오류 코드 및 메시지 존재 확인

**예상 결과:**
- 오류 상태 보고
- 상태에 오류 코드 포함
- 오류 메시지가 설명적임

---

### 3.11 동시 클라이언트 요구사항 (SRS-CONCURRENT)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SRS-CONCURRENT-001 | 다중 클라이언트 | T | TC-CONCURRENT-001, TC-CONCURRENT-002 | P1 |
| SRS-CONCURRENT-002 | 대역폭 조절 | T | TC-CONCURRENT-003, TC-CONCURRENT-004 | P2 |

#### TC-CONCURRENT-001: 100개 동시 클라이언트

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CONCURRENT-001 |
| **SRS 추적** | SRS-CONCURRENT-001, PERF-030 |
| **목적** | 100개 이상 동시 클라이언트 지원 검증 |

**테스트 단계:**
1. 100개 동시 클라이언트 시작
2. 각 클라이언트가 10MB 파일 업로드
3. 서버 리소스 모니터링
4. 모든 완료 대기
5. 실패 없음 확인

**예상 결과:**
- 100개 클라이언트 모두 연결됨
- 모든 업로드 완료
- 각 클라이언트에 독립적인 진행 상황
- 서버 안정 유지

---

#### TC-CONCURRENT-002: 독립적인 진행 상황 추적

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CONCURRENT-002 |
| **SRS 추적** | SRS-CONCURRENT-001 |
| **목적** | 각 클라이언트에 독립적인 추적이 있는지 검증 |

**테스트 단계:**
1. 다른 크기의 파일을 업로드하는 10개 클라이언트 시작
2. 각 클라이언트에 대해 독립적으로 진행 상황 조회
3. 진행 값이 구별되는지 확인

**예상 결과:**
- 각 transfer_id에 고유한 진행 상황
- 진행 콜백이 올바르게 라우팅됨
- 클라이언트 간 간섭 없음

---

#### TC-CONCURRENT-003: 전역 대역폭 조절

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CONCURRENT-003 |
| **SRS 추적** | SRS-CONCURRENT-002 |
| **목적** | 전역 대역폭 제한 검증 |

**테스트 단계:**
1. 서버 전역 대역폭 제한 = 100 MB/s 설정
2. 10개 동시 클라이언트 업로드 시작
3. 총 처리량 측정
4. 제한 허용 오차 내인지 확인

**예상 결과:**
- 총 처리량 ≤ 105 MB/s (5% 허용 오차)
- 대역폭이 클라이언트 간 공정하게 분배됨

---

#### TC-CONCURRENT-004: 클라이언트별 대역폭 제한

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-CONCURRENT-004 |
| **SRS 추적** | SRS-CONCURRENT-002 |
| **목적** | 클라이언트별 대역폭 제한 검증 |

**테스트 단계:**
1. 클라이언트 A 대역폭 = 50 MB/s 설정
2. 클라이언트 B 대역폭 = 무제한 설정
3. 두 업로드 동시 실행
4. 개별 처리량 측정

**예상 결과:**
- 클라이언트 A ≤ 52.5 MB/s (5% 허용 오차)
- 클라이언트 B는 최대 사용 가능 대역폭
- 제한이 즉시 적용됨

---

### 3.12 성능 요구사항 (PERF)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| PERF-001 | LAN 처리량 | T | TC-PERF-001 | P0 |
| PERF-002 | WAN 처리량 | T | TC-PERF-002 | P1 |
| PERF-003 | LZ4 압축 속도 | T | TC-COMP-001 | P0 |
| PERF-004 | LZ4 해제 속도 | T | TC-COMP-003 | P0 |
| PERF-010 | 청크 처리 지연시간 | T | TC-PERF-003 | P1 |
| PERF-020 | 기본 메모리 | T | TC-PERF-004 | P1 |
| PERF-021 | 전송당 메모리 | T | TC-PERF-005 | P1 |
| PERF-022 | CPU 사용률 | T | TC-PERF-006 | P1 |

#### TC-PERF-001: LAN 처리량 벤치마크

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-001 |
| **SRS 추적** | PERF-001 |
| **목적** | ≥500 MB/s LAN 처리량 검증 |

**테스트 단계:**
1. 동일 LAN에서 서버와 클라이언트 설정 (10Gbps)
2. 1GB 파일 업로드
3. 업로드 시간 측정
4. 동일 파일 다운로드
5. 다운로드 시간 측정
6. 양방향 처리량 계산

**예상 결과:**
- 업로드 처리량 ≥ 500 MB/s
- 다운로드 처리량 ≥ 500 MB/s
- 여러 실행에서 일관됨

---

#### TC-PERF-002: WAN 처리량 테스트

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-002 |
| **SRS 추적** | PERF-002 |
| **목적** | 처리량이 네트워크 용량과 일치하는지 검증 |

**테스트 단계:**
1. WAN을 통해 서버와 클라이언트 설정 (시뮬레이션된 100 Mbps)
2. 1GB 파일 업로드
3. 처리량 측정

**예상 결과:**
- 처리량 ≥ 네트워크 용량의 90%
- 프로토콜 오버헤드 < 1%

---

#### TC-PERF-003: 청크 처리 지연시간

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-003 |
| **SRS 추적** | PERF-010 |
| **목적** | 청크 처리 지연시간 < 10ms 검증 |

**테스트 단계:**
1. 청크 처리 경로 계측
2. 1000개 청크에 대한 지연시간 측정
3. p99 지연시간 계산

**예상 결과:**
- 평균 지연시간 < 5ms
- p99 지연시간 < 10ms
- 50ms 초과 지연 스파이크 없음

---

#### TC-PERF-004: 기본 메모리 사용량

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-004 |
| **SRS 추적** | PERF-020 |
| **목적** | 기본 메모리 < 50MB 검증 |

**테스트 단계:**
1. 클라이언트 없이 서버 시작
2. 유휴 클라이언트 시작 (연결되어 있지만 전송 안 함)
3. 유휴 상태 대기
4. 둘 다에 대해 RSS 메모리 사용량 측정

**예상 결과:**
- 유휴 상태에서 서버 RSS 메모리 < 50MB
- 유휴 상태에서 클라이언트 RSS 메모리 < 50MB
- 유휴 시 메모리 증가 없음

---

#### TC-PERF-005: 전송당 메모리 사용량

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-005 |
| **SRS 추적** | PERF-021 |
| **목적** | 전송당 메모리 < 100MB per 1GB 검증 |

**테스트 단계:**
1. 1GB 파일 업로드
2. 업로드 중 피크 메모리 모니터링
3. 1GB 파일 다운로드
4. 다운로드 중 피크 메모리 모니터링

**예상 결과:**
- 1GB 업로드 중 메모리 사용량 < 100MB
- 1GB 다운로드 중 메모리 사용량 < 100MB
- 전송 완료 후 메모리 해제됨

---

#### TC-PERF-006: CPU 사용률

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-PERF-006 |
| **SRS 추적** | PERF-022 |
| **목적** | CPU 사용률 < 코어당 30% 검증 |

**테스트 단계:**
1. 10GB 파일 업로드
2. 코어별 CPU 사용률 모니터링 (서버 및 클라이언트)
3. 평균 사용률 계산

**예상 결과:**
- 코어당 평균 CPU < 30%
- 지속적으로 100%인 코어 없음
- 효율적인 멀티코어 활용

---

### 3.13 보안 요구사항 (SEC)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| SEC-001 | TLS 1.3 암호화 | T, I | TC-SEC-001 | P0 |
| SEC-002 | 인증서 인증 | T | TC-SEC-002 | P1 |
| SEC-003 | 경로 순회 방지 | T | TC-SEC-003 | P0 |
| SEC-004 | 리소스 제한 | T | TC-SEC-004 | P1 |

#### TC-SEC-001: TLS 1.3 암호화 검증

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-SEC-001 |
| **SRS 추적** | SEC-001 |
| **목적** | TLS 1.3 암호화 사용 검증 |

**테스트 단계:**
1. 패킷 캡처 활성화
2. 클라이언트를 서버에 연결
3. 파일 업로드
4. 캡처된 패킷 분석
5. TLS 1.3 핸드셰이크 및 암호화된 페이로드 확인

**예상 결과:**
- TLS 1.3 프로토콜 협상됨
- 모든 데이터 페이로드 암호화됨
- 캡처에서 평문 데이터 보이지 않음

---

#### TC-SEC-002: 인증서 기반 인증

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-SEC-002 |
| **SRS 추적** | SEC-002 |
| **목적** | 인증서 인증 검증 |

**테스트 단계:**
1. 클라이언트 인증서를 요구하도록 서버 설정
2. 인증서 없이 연결 시도 → 실패해야 함
3. 유효한 인증서로 연결 시도 → 성공해야 함
4. 유효하지 않은 인증서로 연결 시도 → 실패해야 함

**예상 결과:**
- 인증되지 않은 연결 거부됨
- 인증된 연결 성공
- 잘못된 인증서 거부됨

---

#### TC-SEC-003: 경로 순회 방지

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-SEC-003 |
| **SRS 추적** | SEC-003 |
| **목적** | 경로 순회 공격 방지 검증 |

**테스트 단계:**
1. 파일명 `../../../etc/passwd`로 파일 업로드 시도
2. 파일명 `../../../etc/passwd`로 파일 다운로드 시도
3. 둘 다 거부되는지 확인

**예상 결과:**
- 경로 순회가 오류 코드 -748 (invalid_filename)로 차단됨
- storage_directory 내에서만 파일 접근 가능
- 보안 이벤트 로깅됨

---

#### TC-SEC-004: 리소스 제한 적용

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-SEC-004 |
| **SRS 추적** | SEC-004 |
| **목적** | 리소스 제한 적용 검증 |

**테스트 단계:**
1. max_file_size = 100MB 설정
2. 200MB 파일 업로드 시도
3. max_connections = 10 설정
4. 15개 클라이언트 연결 시도

**예상 결과:**
- 크기 초과 파일 거부됨
- 초과 연결이 거부되거나 대기열에 추가됨
- 리소스 고갈 방지됨

---

### 3.14 신뢰성 요구사항 (REL)

| SRS ID | 요구사항 | 방법 | 테스트 케이스 | 우선순위 |
|--------|----------|------|---------------|----------|
| REL-001 | 데이터 무결성 | T | TC-CHUNK-007, TC-CHUNK-008 | P0 |
| REL-002 | 재개 성공률 | T | TC-RESUME-003, TC-RESUME-004 | P1 |
| REL-003 | 오류 복구 | T | TC-REL-001 | P1 |
| REL-004 | 우아한 성능 저하 | T | TC-REL-002 | P2 |

#### TC-REL-001: 지수 백오프를 통한 자동 재시도

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-REL-001 |
| **SRS 추적** | REL-003 |
| **목적** | 지수 백오프를 통한 자동 재시도 검증 |

**테스트 단계:**
1. 처음 3번의 연결 시도를 거부하도록 서버 설정
2. auto-reconnect 활성화로 업로드 시도
3. 재시도 동작 모니터링
4. 4번째 시도에서 업로드 완료 확인

**예상 결과:**
- 자동 재시도 발생
- 재시도 간 백오프 증가
- 결국 업로드 성공

---

#### TC-REL-002: 부하 시 우아한 성능 저하

| 속성 | 값 |
|------|-----|
| **테스트 ID** | TC-REL-002 |
| **SRS 추적** | REL-004 |
| **목적** | 과부하 시 우아한 성능 저하 검증 |

**테스트 단계:**
1. 200개 동시 클라이언트 시작 (100개 제한 초과)
2. 서버 동작 모니터링
3. 크래시나 오류 없음 확인

**예상 결과:**
- 서버가 응답 유지
- 초과 클라이언트가 대기열에 추가되거나 속도 제한됨
- 리소스 고갈로 인한 크래시 없음

---

## 4. 검증 일정

### 4.1 1단계: 핵심 인프라 (1-3주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 1 | 빌드 시스템, 기본 구조 | TC-MAINT-001, TC-MAINT-002 |
| 2 | 청크 관리 | TC-CHUNK-001 ~ TC-CHUNK-008 |
| 3 | 서버/클라이언트 프레임워크 | TC-UPLOAD-001, TC-DOWNLOAD-001 |

### 4.2 2단계: 업로드/다운로드 (4-5주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 4 | 업로드 작업 | TC-UPLOAD-001 ~ TC-UPLOAD-006 |
| 5 | 다운로드 작업 | TC-DOWNLOAD-001 ~ TC-DOWNLOAD-005 |

### 4.3 3단계: LZ4 엔진 (6-7주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 6 | 압축/해제 | TC-COMP-001 ~ TC-COMP-004 |
| 7 | 적응형 감지, 통계 | TC-COMP-005 ~ TC-COMP-009 |

### 4.4 4단계: 파이프라인 및 재연결 (8-9주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 8 | 파이프라인 구현 | TC-PIPE-001 ~ TC-PIPE-007 |
| 9 | 자동 재연결 | TC-RECONNECT-001 ~ TC-RECONNECT-004 |

### 4.5 5단계: 재개 및 저장소 (10-11주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 10 | 재개 기능 | TC-RESUME-001 ~ TC-RESUME-005 |
| 11 | 저장소 관리 | TC-STORAGE-001 ~ TC-STORAGE-003 |

### 4.6 6단계: 보안 및 성능 (12-13주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 12 | 보안 검증 | TC-SEC-001 ~ TC-SEC-004 |
| 13 | 성능 벤치마크 | TC-PERF-001 ~ TC-PERF-006 |

### 4.7 7단계: 통합 및 최종 (14-15주차)

| 주차 | 초점 | 테스트 케이스 |
|------|------|---------------|
| 14 | 동시 클라이언트 | TC-CONCURRENT-001 ~ TC-CONCURRENT-004 |
| 15 | 시스템 통합 | 모든 통합 테스트 |

---

## 5. 추적성 요약

### 5.1 요구사항 커버리지

| 카테고리 | 총 요구사항 | 커버됨 | 커버리지 |
|----------|-------------|--------|----------|
| SRS-UPLOAD | 3 | 3 | 100% |
| SRS-DOWNLOAD | 3 | 3 | 100% |
| SRS-LIST | 1 | 1 | 100% |
| SRS-RECONNECT | 2 | 2 | 100% |
| SRS-STORAGE | 2 | 2 | 100% |
| SRS-CHUNK | 4 | 4 | 100% |
| SRS-COMP | 5 | 5 | 100% |
| SRS-PIPE | 4 | 4 | 100% |
| SRS-RESUME | 2 | 2 | 100% |
| SRS-PROGRESS | 2 | 2 | 100% |
| SRS-CONCURRENT | 2 | 2 | 100% |
| PERF | 10 | 10 | 100% |
| SEC | 4 | 4 | 100% |
| REL | 4 | 4 | 100% |
| **총합** | **48** | **48** | **100%** |

### 5.2 테스트 케이스 요약

| 카테고리 | 테스트 케이스 | 우선순위 P0 | 우선순위 P1 | 우선순위 P2 |
|----------|--------------|-------------|-------------|-------------|
| 업로드 | 6 | 6 | 0 | 0 |
| 다운로드 | 5 | 4 | 1 | 0 |
| 목록 | 2 | 0 | 2 | 0 |
| 재연결 | 4 | 4 | 0 | 0 |
| 저장소 | 3 | 2 | 1 | 0 |
| 청크 | 8 | 8 | 0 | 0 |
| 압축 | 9 | 5 | 2 | 2 |
| 파이프라인 | 7 | 4 | 3 | 0 |
| 재개 | 5 | 0 | 5 | 0 |
| 진행 상황 | 4 | 0 | 4 | 0 |
| 동시 | 4 | 0 | 2 | 2 |
| 성능 | 6 | 2 | 4 | 0 |
| 보안 | 4 | 2 | 2 | 0 |
| 신뢰성 | 2 | 0 | 1 | 1 |
| **총합** | **69** | **37** | **27** | **5** |

---

## 부록 A: 테스트 데이터 명세

### A.1 표준 테스트 파일

| 이름 | 크기 | 내용 | 용도 |
|------|------|------|------|
| small.txt | 1 KB | "a" 반복 | 소형 파일 테스트 |
| medium.bin | 64 KB | 랜덤 바이트 | 청크 경계 테스트 |
| large.dat | 256 KB | 랜덤 바이트 | 단일 청크 테스트 |
| text_1mb.log | 1 MB | 로그 파일 형식 | 압축 테스트 |
| binary_1gb.bin | 1 GB | 랜덤 바이트 | 대형 파일 테스트 |
| compressed.zip | 10 MB | 이미 압축됨 | 적응형 압축 테스트 |
| image.jpg | 5 MB | JPEG 이미지 | 압축 불가 데이터 테스트 |

### A.2 생성된 테스트 데이터

```cpp
// 테스트 데이터 생성기 의사코드
auto generate_compressible(size_t bytes) {
    // 반복 패턴 생성 (높은 압축률)
    return repeat_pattern("Lorem ipsum dolor sit amet...", bytes);
}

auto generate_random(size_t bytes) {
    // 암호학적 랜덤 바이트 생성 (압축 불가)
    return crypto_random_bytes(bytes);
}

auto generate_mixed(size_t bytes) {
    // 50% 압축 가능, 50% 랜덤
    return concat(generate_compressible(bytes/2), generate_random(bytes/2));
}
```

---

## 부록 B: 검증 도구

### B.1 필수 도구

| 도구 | 용도 | 버전 |
|------|------|------|
| **Google Test** | 단위 테스팅 프레임워크 | 1.12+ |
| **Google Benchmark** | 성능 벤치마킹 | 1.7+ |
| **gcov/llvm-cov** | 코드 커버리지 | 최신 |
| **AddressSanitizer** | 메모리 오류 감지 | 컴파일러 번들 |
| **ThreadSanitizer** | 데이터 레이스 감지 | 컴파일러 번들 |
| **UBSan** | 정의되지 않은 동작 감지 | 컴파일러 번들 |
| **clang-tidy** | 정적 분석 | 14+ |
| **cppcheck** | 정적 분석 | 2.9+ |

### B.2 테스트 자동화

```yaml
# CI 파이프라인 (의사 설정)
stages:
  - build
  - unit_test
  - integration_test
  - benchmark
  - coverage

build:
  script:
    - cmake -B build -DCMAKE_BUILD_TYPE=Debug
    - cmake --build build

unit_test:
  script:
    - ./build/bin/unit_tests
  artifacts:
    - reports/unit_test_results.xml

integration_test:
  script:
    - ./build/bin/integration_tests
  artifacts:
    - reports/integration_test_results.xml

benchmark:
  script:
    - ./build/bin/benchmarks --benchmark_format=json
  artifacts:
    - reports/benchmark_results.json

coverage:
  script:
    - cmake -B build -DENABLE_COVERAGE=ON
    - cmake --build build
    - ./build/bin/unit_tests
    - gcovr --xml -o coverage.xml
  artifacts:
    - coverage.xml
```

---

## 부록 C: 개정 이력

| 버전 | 날짜 | 작성자 | 설명 |
|------|------|--------|------|
| 1.0.0 | 2025-12-11 | kcenon@naver.com | 초기 SVS 작성 (P2P 모델) |
| 2.0.0 | 2025-12-11 | kcenon@naver.com | Client-Server 아키텍처를 위한 전면 재작성 |

---

*문서 끝*
